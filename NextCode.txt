C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\lib\axios.ts
// lib/axios.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL, // e.g., https://selfservice.dev.att.com/api
  withCredentials: true,
});

api.interceptors.request.use((config) => {
  // Set custom headers
  config.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, post- check=0, pre-check=0';
  config.headers['Pragma'] = 'no-cache';
  config.headers['Expires'] = '0';
  // Example: set xsrf-token from cookie if needed
  if (typeof document !== 'undefined') {
    const xsrfToken = document.cookie
      .split('; ')
      .find(row => row.startsWith('xsrf-token='))
      ?.split('=')[1];
    if (xsrfToken) config.headers['xsrf-token'] = xsrfToken;
  }
  return config;
}, error => Promise.reject(error));

api.interceptors.response.use((response) => {
  // Set xsrf-token cookie from response header if present
  if (typeof document !== 'undefined') {
    const xsrfToken = response.headers['xsrf-token'];
    if (xsrfToken) {
      document.cookie = `xsrf-token=${xsrfToken};SameSite=Strict`;
    }
  }
  return response;
}, (error) => {
  // Handle error
  console.error('Request for', error.config?.url, 'Response Status', error.response?.status, 'With error', error.message);
  return Promise.reject(error);
});

export default api;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\lib\interceptor.ts
// lib/interceptor.ts
export function getXsrfToken(): string | undefined {
  if (typeof document === 'undefined') return undefined;
  return document.cookie
    .split('; ')
    .find(row => row.startsWith('xsrf-token='))
    ?.split('=')[1];
}

export function setXsrfToken(token: string) {
  if (typeof document === 'undefined') return;
  document.cookie = `xsrf-token=${token};SameSite=Strict`;
}

export async function interceptedFetch(input: RequestInfo, init: RequestInit = {}) {
  const xsrfToken = getXsrfToken();
  const headers = {
    'Cache-Control': 'no-cache, no-store, must-revalidate, post- check=0, pre-check=0',
    'Pragma': 'no-cache',
    'Expires': '0',
    ...(xsrfToken ? { 'xsrf-token': xsrfToken } : {}),
    ...(init.headers || {})
  };

  const res = await fetch(input, {
    ...init,
    credentials: 'include',
    headers,
  });

  const xsrfHeader = res.headers.get('xsrf-token');
  if (xsrfHeader) setXsrfToken(xsrfHeader);

  if (!res.ok) {
    // Optionally log or handle error here
    throw new Error(`Request for ${input} failed with status ${res.status}`);
  }

  return res;
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\action-properties\page.tsx
// "use client";
 
// import React, { useEffect, useState } from "react";
// import ActionProperties from "../../components/actions/actionPropertiesForm";
 
// import {
//   getCustomers,
//   getServices,
//   getActionTypes,
//   getVendors,
//   getHostnames,
//   saveAction,
// } from "../../services/controllerService";
 
// async function sleep(ms: number) { return new Promise(r => setTimeout(r, ms)); }

// export default function Page() {
//   const [customers, setCustomers] = useState<any[]>([]);
//   const [isLoading, setIsLoading] = useState(true);

//   useEffect(() => {
//     async function fetchData() {
//       try {
//         const cust = await getCustomers();
//         console.log("✅ Customers from API:", cust);
//         setCustomers(cust);
//       } catch (err) {
//         console.error("❌ Error fetching customers:", err);
//       } finally {
//         setIsLoading(false);
//       }
//     }
//     fetchData();
//   }, []);

//   if (isLoading) return <p>Loading customers...</p>;
//   if (!customers.length) return <p>No customers found.</p>;

//   // Pick first customer for now
//   const customer = customers[0];

//   // Mock attributes (replace with getWorkflowAttributes if backend supports)
//   const actionAttributes = [
//     { id: 3, status: "optional" },  // HOSTNAME_VISIBILITY_ATTRIBUTE_ID
//     { id: 4, status: "optional" },  // CONFIG_TEMPLATE_ATTRIBUTE_ID
//     { id: 5, status: "optional" },  // REPORT_PATH_ATTRIBUTE_ID
//     { id: 6, status: "optional" },  // ROLLBACK_TIMER_ATTRIBUTE_ID
//   ];

//   const actionTemplate = {
//     id: 101,
//     name: "Reboot Agent",
//     description: "Reboot the remote agent",
//     enabled: true,
//     staticHostnameCheckBox: false,
//     staticHostname: null,
//     apiEndpoint: "/api/report",
//     minRollbackTimer: 10,
//     maxRollbackTimer: 60,
//     carcheTemplate: null,
//   };

//   const preselectedServices = [{ id: 1, serviceName: "Windows" }];
//   const preselectedType = null;
//   const preselectedVendor = null;

//   return (
//     <div className="max-w-5xl mx-auto p-6">
//       <ActionProperties
//         actionAttributes={actionAttributes}
//         actionTemplate={actionTemplate}
//         actionServices={preselectedServices}
//         actionType={preselectedType}
//         actionVendor={preselectedVendor}
//         customer={customer}
//         isPropsLoaded={true}

//         loadAllServices={async (customerId?: number) => {
//           await sleep(300);
//           return [
//             { id: 1, serviceName: "Windows" },
//             { id: 2, serviceName: "Linux" },
//           ];
//         }}
//         loadAllActionTypes={async () => {
//           await sleep(300);
//           // Service-aware types
//           return [
//             { ID: 11, NAME: "Patch", service: { ID: 1 } },
//             { ID: 12, NAME: "Reboot", service: { ID: 1 } },
//             { ID: 21, NAME: "Install", service: { ID: 2 } },
//           ];
//         }}
//         loadVendors={async () => {
//           await sleep(300);
//           return [
//             { id: 100, vendorType: "Symantec" },
//             { id: 101, vendorType: "CrowdStrike" },
//           ];
//         }}
//         loadHostnamesByCustomer={async () => {
//           await sleep(300);
//           return [
//             { HOSTNAME: "srv-01" },
//             { HOSTNAME: "srv-02" },
//           ];
//         }}
//         loadConfigTemplates={async () => {
//           await sleep(300);
//           return [
//             { id: 900, name: "Win Reboot Std", services: "1", contractid: "77", vendorType: "100" },
//             { id: 901, name: "Linux Install Std", services: "2", contractid: "77", vendorType: "101" },
//           ];
//         }}

//         onSaveAction={async (payload: any) => {
//           console.log("SAVE payload ->", payload);
//           await sleep(500);
//           // Here call your real backend: fetch("/api/...",{method:"POST",body:JSON.stringify(payload)})
//         }}
//       />
//     </div>
//   );
// }

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\form-rules\formRulesTab.tsx
"use client";

import React, { useEffect, useState, useCallback } from "react";
import {
  fetchFormRules,
  createFormRule,
  editFormRule,
  deleteFormRule,
  incrementFormRuleSequence,
  FormRule,
  WhenCondition,
  ThenCondition,
} from "../../../services/formRulesService";
import { Button, Modal, message, Table, Popconfirm } from "antd";
import { PlusOutlined, UpOutlined, DownOutlined, EditOutlined, DeleteOutlined } from "@ant-design/icons";
import RuleEditModal from "./RuleEditModal";

interface Props {
  actionId: number;
  templateId: number;
}

function parseWhen(when: WhenCondition[]) {
  return when
    .map((wc) => {
      const parts = [];
      if (wc.operation) parts.push(wc.operation);
      parts.push(wc.source_key, wc.condition);
      if (wc.value) parts.push(`"${wc.value}"`);
      return parts.join(" ");
    })
    .join(", ");
}

function parseThen(then: ThenCondition[]) {
  return then
    .map((tc) => `${tc.action} ${tc.target_key} "${tc.target_value}"`)
    .join(", ");
}

export default function FormRulesTab({ actionId, templateId }: Props) {
  const [rules, setRules] = useState<FormRule[]>([]);
  const [loading, setLoading] = useState(false);
  const [editRule, setEditRule] = useState<FormRule | null>(null);
  const [modalOpen, setModalOpen] = useState(false);

  const loadRules = useCallback(async () => {
    setLoading(true);
    try {
      const result = await fetchFormRules(actionId, "customer"); // includes belongsTo
      // const result = await fetchFormRules(actionId);
      setRules(result);
    } catch {
      message.error("Failed to load form rules for the action");
    }
    setLoading(false);
  }, [actionId]);

  useEffect(() => {
    if (!isNaN(actionId)) {
      loadRules();
    } else {
      setRules([]);
    }
  }, [actionId, loadRules]);

  const minSeq = rules.length ? Math.min(...rules.map((r) => r.SEQUENCE)) : 0;
  const maxSeq = rules.length ? Math.max(...rules.map((r) => r.SEQUENCE)) : 0;

  const handleAdd = () => {
    setEditRule(null);
    setModalOpen(true);
  };

  const handleEdit = (rule: FormRule) => {
    setEditRule(rule);
    setModalOpen(true);
  };

  const handleDelete = async (id: number) => {
    setLoading(true);
    try {
      await deleteFormRule(id);
      message.success("Form rule deleted successfully!");
      loadRules();
    } catch {
      message.error("Failed to delete the form rule");
    }
    setLoading(false);
  };

  const handleIncrement = async (id: number, increment: boolean) => {
    setLoading(true);
    try {
      await incrementFormRuleSequence(id, increment);
      loadRules();
    } catch {
      loadRules();
    }
    setLoading(false);
  };

  return (
    <div style={{ background: "white", padding: 24 }}>
      <h2>Form Rules</h2>
      <Button
        icon={<PlusOutlined />}
        type="primary"
        style={{ marginBottom: 16 }}
        onClick={handleAdd}
        disabled={loading}
      >
        Add Form Rule
      </Button>
      <Table
        dataSource={rules}
        rowKey="ID"
        loading={loading}
        pagination={false}
        bordered
        columns={[
          {
            title: "Sequence",
            dataIndex: "SEQUENCE",
            render: (_value, record: FormRule) => (
              <span>
                {record.SEQUENCE !== maxSeq && (
                  <Button
                    icon={<DownOutlined />}
                    size="small"
                    style={{ marginRight: 4 }}
                    onClick={() => handleIncrement(record.ID, true)}
                    disabled={loading}
                  />
                )}
                {record.SEQUENCE !== minSeq && (
                  <Button
                    icon={<UpOutlined />}
                    size="small"
                    style={{ marginRight: 4 }}
                    onClick={() => handleIncrement(record.ID, false)}
                    disabled={loading}
                  />
                )}
                <span>{record.SEQUENCE}</span>
              </span>
            ),
          },
          {
            title: "When Conditions",
            render: (_, record: FormRule) => parseWhen(record.WHEN_CONDITIONS),
          },
          {
            title: "Then Conditions",
            render: (_, record: FormRule) => parseThen(record.THEN_CONDITIONS),
          },
          {
            title: "Actions",
            render: (_, record: FormRule) => (
              <>
                <Button
                  icon={<EditOutlined />}
                  size="small"
                  onClick={() => handleEdit(record)}
                  style={{ marginRight: 4 }}
                  disabled={loading}
                />
                <Popconfirm
                  title="Delete form rule?"
                  onConfirm={() => handleDelete(record.ID)}
                  okText="Yes"
                  cancelText="No"
                >
                  <Button icon={<DeleteOutlined />} size="small" danger disabled={loading} />
                </Popconfirm>
              </>
            ),
          },
        ]}
      />
      <RuleEditModal
        open={modalOpen}
        onCancel={() => setModalOpen(false)}
        onOk={async (when, then, ruleId) => {
          setLoading(true);
          try {
            if (ruleId) {
              await editFormRule(ruleId, when, then);
              message.success("Form rule saved successfully!");
            } else {
              await createFormRule(actionId, 0, when, then);
              message.success("Form rule saved successfully!");
            }
            setModalOpen(false);
            loadRules();
          } catch {
            message.error("Failed to save the form rule");
          }
          setLoading(false);
        }}
        rule={editRule}
        templateId={templateId}
      />
    </div>
  );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\form-rules\page.tsx
// "use client";

// import { useSearchParams } from "next/navigation";
// import FormRulesTab from "./formRulesTab";


// export default function FormRulesPage() {
//   const searchParams = useSearchParams();
//   const actionId = Number(searchParams.get("actionId"));
//   // const belongsTo = searchParams.get("belongsTo") || "customer";

//   return (
//     <FormRulesTab actionId={actionId} templateId={actionId} />
//   );
// }

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\form-rules\RuleEditModal.tsx
"use client";

import React, { useEffect, useState } from "react";
import { Modal, Button, Input, Select, Space, Tooltip } from "antd";
import { PlusOutlined, MinusCircleOutlined } from "@ant-design/icons";
import { FormRule, WhenCondition, ThenCondition } from "../../../services/formRulesService";
import { getFormTemplateById } from "../../../services/controllerService";

interface Props {
  open: boolean;
  onCancel: () => void;
  onOk: (when: WhenCondition[], then: ThenCondition[], ruleId?: number) => void;
  rule: FormRule | null;
  templateId: number;
}

type FieldOption = { key: string; label: string };

// These match the Angular app's logic exactly!
const conditionOptions = [
  { value: "starts with", label: "starts with", hasValue: true },
  { value: "ends with", label: "ends with", hasValue: true },
  { value: "contains", label: "contains", hasValue: true },
  { value: "is", label: "is", hasValue: true },
  { value: "is not", label: "is not", hasValue: true },
  { value: "is empty", label: "is empty", hasValue: false },
  { value: "is not empty", label: "is not empty", hasValue: false },
  { value: "is one of", label: "is one of", hasValue: true },
];

const actionOptions = [
  { value: "set", label: "set", hasValue: true },
  { value: "hide", label: "hide", hasValue: false },
];

const operationOptions = [
  { value: "OR", label: "OR" },
  { value: "AND", label: "AND" },
];

export default function RuleEditModal({
  open,
  onCancel,
  onOk,
  rule,
  templateId,
}: Props) {
  const [fields, setFields] = useState<FieldOption[]>([]);
  const [when, setWhen] = useState<any[]>([]);
  const [then, setThen] = useState<any[]>([]);
  const belongsTo = "customer"; // Centralized

  // Load fields when templateId or modal opens
  useEffect(() => {
    async function loadFields() {
      try {
        const res = await getFormTemplateById(templateId);
        // supports both "questions" or "QUESTIONS" as per backend variations
        const q = res?.result?.questions || res?.result?.QUESTIONS || [];
        setFields(q.map((f: any) => ({ key: f.key, label: f.label || f.key })));
      } catch {
        setFields([]);
      }
    }
    if (open && templateId) loadFields();
  }, [open, templateId]);

  // When editing a rule, populate from rule.
  useEffect(() => {
    if (rule) {
      setWhen(
        rule.WHEN_CONDITIONS.length > 0
          ? rule.WHEN_CONDITIONS.map((w) => ({ ...w }))
          : [{ source_key: "", condition: "", value: "", operation: undefined }]
      );
      setThen(
        rule.THEN_CONDITIONS.length > 0
          ? rule.THEN_CONDITIONS.map((t) => ({ ...t }))
          : [{ target_key: "", action: "", target_value: "" }]
      );
    }
  }, [rule, open]);

  // FIX: When opening modal for "add" (not edit) and fields have loaded, reset to 1 blank row
  useEffect(() => {
    if (open && fields.length > 0 && !rule) {
      setWhen([{ source_key: "", condition: "", value: "", operation: undefined }]);
      setThen([{ target_key: "", action: "", target_value: "" }]);
    }
  }, [open, fields, rule]);

  const handleWhenChange = (i: number, key: string, value: any) => {
    setWhen((prev) => prev.map((w, idx) => (idx === i ? { ...w, [key]: value } : w)));
  };
  const handleThenChange = (i: number, key: string, value: any) => {
    setThen((prev) => prev.map((t, idx) => (idx === i ? { ...t, [key]: value } : t)));
  };

  const addWhen = () =>
    setWhen((prev) => [
      ...prev,
      {
        source_key: "",
        condition: "is",
        value: "",
        operation: "OR",
      },
    ]);
  const removeWhen = (i: number) =>
    setWhen((prev) => (prev.length > 1 ? prev.filter((_, idx) => idx !== i) : prev));

  const addThen = () =>
    setThen((prev) => [
      ...prev,
      { target_key: "", action: "set", target_value: "" },
    ]);
  const removeThen = (i: number) =>
    setThen((prev) => (prev.length > 1 ? prev.filter((_, idx) => idx !== i) : prev));

  const isFormValid = () =>
    when.every((w) => w.source_key && w.condition && (w.value || w.value === "" || conditionOptions.find(c => c.value === w.condition)?.hasValue === false)) &&
    then.every((t) => t.target_key && t.action && (t.target_value || t.target_value === "" || actionOptions.find(a => a.value === t.action)?.hasValue === false));

  return (
    <Modal
      title={
        <span style={{ fontWeight: 700, fontSize: "1.18rem", color: "#232947" }}>
          {rule ? "Edit Form Rule" : "Add New Form Rule"}
        </span>
      }
      open={open}
      onCancel={onCancel}
      onOk={() =>
        onOk(
          when.map(({ source_key, condition, value, operation }) => ({
            source_key,
            condition,
            value,
            ...(operation ? { operation } : {}),
          })),
          then.map(({ target_key, action, target_value }) => ({
            target_key,
            action,
            target_value,
          })),
          rule?.ID
        )
      }
      okButtonProps={{
        disabled: !isFormValid(),
        style: {
          background: "#61b5fa",
          borderColor: "#61b5fa",
          color: "#fff",
          fontWeight: 600,
        },
      }}
      cancelText="Discard"
      cancelButtonProps={{
        style: {
          background: "#f1f3f6",
          color: "#232947",
          fontWeight: 600,
        },
      }}
      width={720}
      maskClosable={false}
      destroyOnHidden
    >
      <div>
        <strong style={{ fontSize: "1.05rem", color: "#232947" }}>When Conditions</strong>
        {when.map((w, i) => (
          <Space key={i} style={{ display: "flex", marginBottom: 10 }} align="start">
            <Select
              style={{ width: 110 }}
              placeholder="Operation"
              value={w.operation}
              onChange={(val) => handleWhenChange(i, "operation", val)}
              options={operationOptions}
              allowClear
              disabled={i === 0}
            />
            <Select
              style={{ width: 180 }}
              placeholder="Source Key"
              value={w.source_key}
              onChange={(val) => handleWhenChange(i, "source_key", val)}
              options={fields.map((f) => ({ value: f.key, label: f.label }))}
            />
            <Select
              style={{ width: 130 }}
              placeholder="Condition"
              value={w.condition}
              onChange={(val) => handleWhenChange(i, "condition", val)}
              options={conditionOptions}
            />
            {conditionOptions.find((c) => c.value === w.condition)?.hasValue && (
              <Input
                style={{ width: 130 }}
                placeholder="Value"
                value={w.value}
                onChange={(e) => handleWhenChange(i, "value", e.target.value)}
              />
            )}
            {when.length > 1 && (
              <Tooltip title="Remove Condition">
                <Button
                  icon={<MinusCircleOutlined />}
                  onClick={() => removeWhen(i)}
                  danger
                  type="text"
                />
              </Tooltip>
            )}
          </Space>
        ))}
        <Button
          icon={<PlusOutlined />}
          type="dashed"
          onClick={addWhen}
          style={{ marginBottom: 12, marginTop: 0, width: 40, padding: 0 }}
          aria-label="Add Condition"
        />
      </div>
      <div style={{ marginTop: 18 }}>
        <strong style={{ fontSize: "1.05rem", color: "#232947" }}>Then Conditions</strong>
        {then.map((t, i) => (
          <Space key={i} style={{ display: "flex", marginBottom: 10 }} align="start">
            <Select
              style={{ width: 180 }}
              placeholder="Target Key"
              value={t.target_key}
              onChange={(val) => handleThenChange(i, "target_key", val)}
              options={fields.map((f) => ({ value: f.key, label: f.label }))}
            />
            <Select
              style={{ width: 110 }}
              placeholder="Action"
              value={t.action}
              onChange={(val) => handleThenChange(i, "action", val)}
              options={actionOptions}
            />
            {actionOptions.find((a) => a.value === t.action)?.hasValue && (
              <Input
                style={{ width: 130 }}
                placeholder="Target Value"
                value={t.target_value}
                onChange={(e) => handleThenChange(i, "target_value", e.target.value)}
              />
            )}
            {then.length > 1 && (
              <Tooltip title="Remove Then">
                <Button
                  icon={<MinusCircleOutlined />}
                  onClick={() => removeThen(i)}
                  danger
                  type="text"
                />
              </Tooltip>
            )}
          </Space>
        ))}
        <Button
          icon={<PlusOutlined />}
          type="dashed"
          onClick={addThen}
          style={{ marginBottom: 0, marginTop: 0, width: 40, padding: 0 }}
          aria-label="Add Then"
        />
      </div>
    </Modal>
  );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\store\actionDataStore.ts
// src/app/actions/store/actionDataStore.ts
import { create } from "zustand";
import {
    getFormTemplateById,
    // getTemplateToRole,
    // getTemplateToBcUser,
} from "../../../services/controllerService"; // uses your file in src/app/services or src/services
import controllerService from "../../../services/controllerService"; // fallback to call other endpoints

type AccessBundle = {
    toUser?: any;
    toRole?: any;
    toBcUser?: any;
    raw?: any;
};

type State = {
    loading: boolean;
    error: string | null;
    template: any | null;
    accessData: AccessBundle | null;
    formRules: any[] | null; // form rules loaded separately if needed
    loadAll: (opts: { templateId?: number | null; serviceId?: number | null; customerId?: number | null }) => Promise<void>;
    clear: () => void;
};

export const useActionDataStore = create<State>((set) => ({
    loading: false,
    error: null,
    template: null,
    accessData: null,
    formRules: null,

    loadAll: async ({ templateId, serviceId, customerId }) => {
        set({ loading: true, error: null });
        try {
            const tId = Number(templateId) || undefined;

            // Important: call only if templateId is present
            const pTemplate = tId ? await getFormTemplateById(tId) : null;

            // Access calls: use controllerService helpers (some may return .data or .result)
            const [toUser, toRole, toBcUser] = await Promise.all([
                tId ? controllerService.getTemplateToUser?.(tId).catch(() => null) : Promise.resolve(null),
                tId ? controllerService.getTemplateToRole?.(tId).catch(() => null) : Promise.resolve(null),
                tId ? controllerService.getTemplateToBcUser?.(tId).catch(() => null) : Promise.resolve(null),
            ]);

            // If you have a form-rules endpoint you can fetch here (optional)
            let rules = null;
            try {
                if (tId && (controllerService as any).getFormRulesForTemplate) {
                    rules = await (controllerService as any).getFormRulesForTemplate(tId);
                }
            } catch (e) {
                rules = null;
            }

            set({
                template: pTemplate?.result ?? pTemplate ?? null,
                accessData: { toUser, toRole, toBcUser, raw: { templateId, serviceId, customerId } },
                formRules: rules ?? null,
                loading: false,
            });
        } catch (err: any) {
            set({ error: err?.message ?? "Load failed", loading: false });
            console.error("actionDataStore.loadAll error", err);
        }
    },

    clear: () => set({ template: null, accessData: null, formRules: null, loading: false, error: null }),
}));

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\store\actionSelectionStore.ts
// src/app/actions/store/actionSelectionStore.ts
import { create } from "zustand";
 
export type SelectedNode = {
  type: "customer" | "service" | null;
  id: string | number | null;        // the node id (template id for leaves)
  templateId?: number | null;
  serviceId?: number | null;
  customerId?: number | null;
};
 
type State = {
  selectedNode: SelectedNode | null;
  setSelectedNode: (node: SelectedNode | null) => void;
  clearSelection: () => void;
};
 
export const useActionSelectionStore = create<State>((set) => ({
  selectedNode: null,
  setSelectedNode: (node) => set({ selectedNode: node }),
  clearSelection: () => set({ selectedNode: null }),
}));

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\actions\page.tsx
// src/app/actions/page.tsx
"use client";

import React, { useEffect } from "react";
import { Tabs } from "antd";
import ListTemplates from "../configurationTemplate/list_templates/list_templates";
import ActionPropertiesForm from "../components/actions/actionPropertiesForm";
import ActionAccess from "../components/actions/action-access/action-access";
import FormRulesTab from "./form-rules/formRulesTab";

import { useActionSelectionStore } from "./store/actionSelectionStore";
import { useActionDataStore } from "./store/actionDataStore";

/**
* ActionsPage:
* - left panel: ListTemplates (reuse)
* - right panel: renders tabs only when a selection exists and data is loaded
*/
export default function ActionsPage() {
    const selectedNode = useActionSelectionStore((s) => s.selectedNode);
    const loadAll = useActionDataStore((s) => s.loadAll);
    const template = useActionDataStore((s) => s.template);
    const accessData = useActionDataStore((s) => s.accessData);
    const loading = useActionDataStore((s) => s.loading);
    const clear = useActionDataStore((s) => s.clear);

    // whenever selection changes, load everything
    useEffect(() => {
        if (selectedNode) {
            void loadAll({
                templateId: selectedNode.templateId ?? Number(selectedNode.id),
                serviceId: selectedNode.serviceId ?? undefined,
                customerId: selectedNode.customerId ?? undefined,
            });
        } else {
            clear();
        }
    }, [selectedNode, loadAll, clear]);

    // Build tab items only after we have selection and the loader is done
    // Build tab items only after we have selection and the loader is done
    const tabItems: { key: string; label: string; children: React.ReactNode }[] = [];
    if (selectedNode && !loading && template) {
        tabItems.push({
            key: "properties",
            label: "Properties",
            children: (
                <ActionPropertiesForm
                    selectionType={selectedNode.type ?? ""}
                    selectionId={String(selectedNode.id ?? "")}
                />
            ),
        });
        tabItems.push({
            key: "accesses",
            label: "Accesses",
            children: (
                <ActionAccess
                    selectionType={selectedNode.type ?? ""}
                    selectionId={String(selectedNode.id ?? "")}
                />
            ),
        });
        tabItems.push({
            key: "formRules",
            label: "Form Rules",
            children: (
                <FormRulesTab
                    actionId={Number(selectedNode.templateId ?? selectedNode.id ?? 0)}
                    templateId={Number(selectedNode.templateId ?? selectedNode.id ?? 0)}
                />
            ),
        });
        // Add more tabs here (e.g., Validations, Form Builder) as needed:
        // tabItems.push({ key: "validations", label: "Validations", children: <ValidationsTab ... /> });
        // tabItems.push({ key: "formBuilder", label: "Form Builder", children: <FormBuilderTab ... /> });
    }

    return (
        <div style={{ display: "flex", height: "100vh" }}>
            {/* Left panel */}
            <div style={{ width: "24%", borderRight: "1px solid #e6e6e6", padding: 12 }}>
                <ListTemplates />
            </div>

            {/* Right panel */}
            <div style={{ flex: 1, padding: 24, background: "#f5f5f5" }}>
                {!selectedNode && (
                    <h2 style={{ color: "#888", textAlign: "center", marginTop: 120 }}>
                        Please select a customer or service from the left panel
                    </h2>
                )}

                {selectedNode && loading && (
                    <h2 style={{ color: "#888", textAlign: "center", marginTop: 120 }}>
                        Loading action data...
                    </h2>
                )}

                {selectedNode && !loading && tabItems.length > 0 && (
                    <Tabs defaultActiveKey={tabItems[0].key} type="card" items={tabItems} />
                )}

                {selectedNode && !loading && tabItems.length === 0 && (
                    <h2 style={{ color: "#888", textAlign: "center", marginTop: 120 }}>
                        No tabs available for selected item
                    </h2>
                )}
            </div>
        </div>
    );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\api\form-template\[id]\route.ts
import { NextRequest, NextResponse } from "next/server";
import httpClient from "../../../../services/httpClient";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Call your backend for the template with the given id
    const res = await httpClient.get(`/action-template/${params.id}`);
    // Return the backend response data as JSON
    return NextResponse.json(res.data);
  } catch (err: any) {
    // Return error as JSON with status 500
    return NextResponse.json(
      { error: err.message || "Failed to fetch template" },
      { status: 500 }
    );
  }
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\components\actions\action-access\action-access.tsx
"use client";
import { Fieldset } from 'primereact/fieldset';
import { Dropdown } from 'primereact/dropdown';
import { Button } from 'primereact/button';
import { Tooltip } from 'primereact/tooltip';
import styles from './action-access.module.css';
import React, { useEffect, useState } from "react";
import { toast } from "react-toastify";

// Import your services (you’ll need to implement API calls here)

// Update the import path below if the actual location is different
// Update the import path below to the correct location if needed
import { actionService } from "@/services/actionService";
import controllerService from "@/services/controllerService";

interface Access {
  ID: number;
  [key: string]: any;
  inherited?: boolean;
}

interface ActionAccessProps {
  selectionType: string;
  selectionId: string;
}

const ActionAccess: React.FC<ActionAccessProps> = ({ selectionType, selectionId }) => {

  const [loaders, setLoaders] = useState<Record<string, boolean>>({});
  const [errors, setErrors] = useState<Record<string, any>>({});
  const [selectedGroup, setSelectedGroup] = useState<Access | null>(null);
  const [assignedGroupAccess, setAssignedGroupAccess] = useState<Access[]>([]);
  const [filteredGroupAccess, setFilteredGroupAccess] = useState<Access[]>([]);
  const [selectedIndividual, setSelectedIndividual] = useState<Access | null>(
    null
  );
  const [assignedIndividualAccess, setAssignedIndividualAccess] = useState<
    Access[]
  >([]);
  const [filteredIndividualAccess, setFilteredIndividualAccess] = useState<
    Access[]
  >([]);
  const [selectedBcUser, setSelectedBcUser] = useState<Access | null>(null);
  const [assignedBcUserAccess, setAssignedBcUserAccess] = useState<Access[]>([]);
  const [filteredBcUserAccess, setFilteredBcUserAccess] = useState<Access[]>([]);
  // ✅ Equivalent of ngOnInit

  useEffect(() => {
    // Example: fetch access data based on selectionType and selectionId
    if (selectionType && selectionId) {
      // If you need selectionType/selectionId, set them in a context/service here
      // Then call load*Accesses with no arguments
      loadIndividualAccesses();
      loadGroupAccesses();
      loadBcUserAccesses();
    }
    // If you use subscriptions, handle them here
    // return () => { ... };
  }, [selectionType, selectionId]);

  // Update your load*Accesses functions to accept selectionType/selectionId as needed

  // Filter available groups for dropdown, using cache if available
  const filterGroups = async () => {
    const cachedGroups = actionService.getActionCache && actionService.getActionCache('groups');
    if (cachedGroups) {
      setFilteredGroupAccess([...cachedGroups]);
      return;
    }
    setLoaders(prev => ({ ...prev, group: true }));
    setErrors(prev => ({ ...prev, group: null }));
    try {
      const groups = await controllerService.getRoles();
      // Set the cache if method exists
      if (actionService.setActionCache) {
        actionService.setActionCache('groups', groups);
      }
      setFilteredGroupAccess([...groups]);
    } catch (error) {
      setErrors(prev => ({ ...prev, group: { message: 'Unable to load available groups' } }));
    } finally {
      setLoaders(prev => ({ ...prev, group: false }));
    }
  };

  // Filter available business center users for dropdown, using cache if available
  const filterBcCustomers = async () => {
    const cachedBcCustomers = actionService.getActionCache && actionService.getActionCache('bcCustomers');
    if (cachedBcCustomers) {
      setFilteredBcUserAccess([...cachedBcCustomers]);
      return;
    }
    setLoaders(prev => ({ ...prev, 'bc-user': true }));
    setErrors(prev => ({ ...prev, 'bc-user': null }));
    try {
      const bcCustomers = await controllerService.getBcUsers();
      if (actionService.setActionCache) {
        actionService.setActionCache('bcCustomers', bcCustomers);
      }
      setFilteredBcUserAccess([...bcCustomers]);
    } catch (error) {
      setErrors(prev => ({ ...prev, 'bc-user': { message: 'Unable to load available bc users' } }));
    } finally {
      setLoaders(prev => ({ ...prev, 'bc-user': false }));
    }
  };

  // Filter available individuals for dropdown, using cache if available
  const filterIndividuals = async () => {
    const cachedIndividuals = actionService.getActionCache && actionService.getActionCache('individuals');
    if (cachedIndividuals) {
      setFilteredIndividualAccess([...cachedIndividuals]);
      return;
    }
    setLoaders(prev => ({ ...prev, individual: true }));
    setErrors(prev => ({ ...prev, individual: null }));
    try {
      const individuals = await controllerService.getExistingUsersFromDB();
      if (actionService.setActionCache) {
        actionService.setActionCache('individuals', individuals);
      }
      setFilteredIndividualAccess([...individuals]);
    } catch (error) {
      setErrors(prev => ({ ...prev, individual: { message: 'Unable to load available individuals' } }));
    } finally {
      setLoaders(prev => ({ ...prev, individual: false }));
    }
  };

  const onAssignIndividualAccess = async () => {
    if (!selectedIndividual) return;
    setLoaders(prev => ({ ...prev, ['individual-assign']: true }));
    try {
      await controllerService.assignTemplateToUser(selectedIndividual.ID, actionService.actionTemplate.id);
      setAssignedIndividualAccess(prev => {
        const updated = [...prev, { ...selectedIndividual, inherited: false }];
        // Update cache
        actionService.action.actionAccesses.individual = [...updated];
        return updated;
      });
      setSelectedIndividual(null);
      toast.success('Successfully assigned access for the selected individual!');
    } catch (error) {
      toast.error('Failed to assign access for the selected individual!');
    } finally {
      setLoaders(prev => ({ ...prev, ['individual-assign']: false }));
    }
  };

  /** -------------------------

   * LOAD FUNCTIONS

   * ------------------------- */

  const loadIndividualAccesses = async () => {
    const cached = actionService.action.actionAccesses.individual;
    if (cached) {
      setAssignedIndividualAccess([...cached]);
      return;
    }

    try {
      setLoaders((l) => ({ ...l, ["individual-load"]: true }));
      const { id } = actionService.actionTemplate;
      const [service] = actionService.actionServices;
      let inherited = await controllerService.getUserForServices(service.id);
      if (actionService.customer?.id) {
        inherited = await controllerService.getUsersForServiceAndCustomer(
          actionService.customer.id,
          service.id
        );
      }

      const [inhResp, tmplResp] = await Promise.all([
        inherited,
        controllerService.getTemplateToUser(id),
      ]);

      const combined = [
        ...(inhResp?.result || []).map((inh: any) => ({
          ...inh,
          inherited: true,
        })),
        ...(tmplResp || []).map((tmp: any) => ({
          ...tmp,
          inherited: false,
        })),
      ];

      setAssignedIndividualAccess(combined);

      actionService.action.actionAccesses.individual = [...combined];
    } catch (err) {
      setErrors((e) => ({
        ...e,
        ["individual-load"]: {
          status: 501,
          message: "Unable to load assigned individual accesses",
        },
      }));

    } finally {
      setLoaders((l) => ({ ...l, ["individual-load"]: false }));
    }

  };

  const loadGroupAccesses = async () => {
    const cached = actionService.action.actionAccesses.group;
    if (cached) {
      setAssignedGroupAccess([...cached]);
      return;
    }

    try {
      setLoaders((l) => ({ ...l, ["group-load"]: true }));
      const { id } = actionService.actionTemplate;
      const [service] = actionService.actionServices;
      let inherited = await controllerService.getRolesForServices(service.id);
      if (actionService.customer?.id) {
        inherited = await controllerService.getRolesForServiceAndCustomer(
          String(actionService.customer.id),
          String(service.id)
        );
      }

      const [inhResp, tmplResp] = await Promise.all([
        inherited,
        controllerService.getTemplateToRole(id),
      ]);

      const combined = [
        ...(inhResp?.result || []).map((inh: any) => ({
          ...inh,
          inherited: true,
        })),

        ...(tmplResp || []).map((tmp: any) => ({
          ...tmp,
          inherited: false,
        })),

      ];

      setAssignedGroupAccess(combined);

      actionService.action.actionAccesses.group = [...combined];

    } catch {

      setErrors((e) => ({
        ...e,
        ["group-load"]: {
          status: 501,
          message: "Unable to load assigned group accesses",
        },
      }));

    } finally {

      setLoaders((l) => ({ ...l, ["group-load"]: false }));

    }

  };

  const loadBcUserAccesses = async () => {

    const cached = actionService.action.actionAccesses.businessCenter;

    if (cached) {

      setAssignedBcUserAccess([...cached]);

      return;

    }

    try {

      setLoaders((l) => ({ ...l, ["bc-user-load"]: true }));
      const { id } = actionService.actionTemplate;
      const [service] = actionService.actionServices;
      let inherited = await controllerService.getBcUserForServices(service.id);
      if (actionService.customer?.id) {
        inherited =
          await controllerService.getBcUserForServiceAndCustomer(
            actionService.customer.id,
            service.id
          );
      }
      const [inhResp, tmplResp] = await Promise.all([
        inherited,
        controllerService.getTemplateToBcUser(id),
      ]);

      const combined = [
        ...(inhResp?.result || []).map((inh: any) => ({
          ...inh,
          inherited: true,
        })),
        ...(tmplResp || []).map((tmp: any) => ({
          ...tmp,
          inherited: false,
        })),
      ];

      setAssignedBcUserAccess(combined);
      actionService.action.actionAccesses.businessCenter = [...combined];
    } catch {

      setErrors((e) => ({
        ...e,
        ["bc-user-load"]: {
          status: 501,
          message: "Unable to load assigned bc user accesses",
        },
      }));

    } finally {
      setLoaders((l) => ({ ...l, ["bc-user-load"]: false }));
    }

  };

  /** -------------------------

   * ASSIGN/REMOVE FUNCTIONS

   * ------------------------- */

  const onAssignGroupAccess = async () => {
    if (!selectedGroup) return;
    try {
      setLoaders((l) => ({ ...l, ["group-assign"]: true }));
      await controllerService.assignTemplateToRole(
        selectedGroup.ID,
        actionService.actionTemplate.id
      );
      setAssignedGroupAccess((prev) => [
        ...prev,
        { ...selectedGroup, inherited: false },
      ]);
      setSelectedGroup(null);
      toast.success("Successfully assigned access for the selected group!");
    } catch {
      toast.error("Failed to assign access for the selected group!");
    } finally {
      setLoaders((l) => ({ ...l, ["group-assign"]: false }));
    }
  };

  const onRemoveGroupAccess = async (id: number) => {

    if (!id) return;

    try {

      setLoaders((l) => ({ ...l, [`group-revoke-${id}`]: true }));

      await controllerService.deleteRoleForActionTemplate(

        id,

        actionService.actionTemplate.id

      );

      setAssignedGroupAccess((prev) =>

        prev.filter((gr) => !(gr.ID === id && !gr.inherited))

      );

      toast.success("Successfully revoked access for the selected group!");

    } catch {

      toast.error("Failed to revoke access for the selected group!");

    } finally {

      setLoaders((l) => ({ ...l, [`group-revoke-${id}`]: false }));

    }

  };


  const onRemoveIndividualAccess = async (id: number) => {
    if (!id) return;
    setLoaders(prev => ({ ...prev, [`individual-revoke-${id}`]: true }));
    try {
      await controllerService.deleteUsersForActionTemplate(id, actionService.actionTemplate.id);
      const updatedAccess = assignedIndividualAccess.filter(
        acc => !(acc.ID === id && !acc.inherited)
      );
      setAssignedIndividualAccess(updatedAccess);
      // Update cache if needed
      actionService.action.actionAccesses.individual = [...updatedAccess];
      toast.success('Successfully revoked access for the selected individual!');
    } catch (error) {
      toast.error('Failed to revoke access for the selected individual!');
    } finally {
      setLoaders(prev => ({ ...prev, [`individual-revoke-${id}`]: false }));
    }
  };

  const onAssignBcUserAccess = async () => {
    if (!selectedBcUser) return;
    setLoaders(prev => ({ ...prev, ['bc-user-assign']: true }));
    try {
      await controllerService.assignTemplateToBCUser(selectedBcUser.ID, actionService.actionTemplate.id);
      setAssignedBcUserAccess(prev => {
        const updated = [...prev, { ...selectedBcUser, inherited: false }];
        // Update cache
        if (actionService.action && actionService.action.actionAccesses) {
          actionService.action.actionAccesses.businessCenter = [...updated];
        }
        return updated;
      });
      setSelectedBcUser(null);
      toast.success('Successfully assigned access for the selected bc user!');
    } catch (error) {
      toast.error('Failed to assign access for the selected bc user!');
    } finally {
      setLoaders(prev => ({ ...prev, ['bc-user-assign']: false }));
    }
  };

  const onRemoveBcUserAccess = async (id: number) => {
    if (!id) return;
    setLoaders(prev => ({ ...prev, [`bc-user-revoke-${id}`]: true }));
    try {
      await controllerService.deleteBcUserForActionTemplate(id, actionService.actionTemplate.id);
      setAssignedBcUserAccess(prev => {
        const updated = prev.filter(acc => !(acc.ID === id && !acc.inherited));
        // Update cache
        actionService.action.actionAccesses.businessCenter = [...updated];
        return updated;
      });
      toast.success('Successfully revoked access for the selected bc user!');
    } catch (error) {
      toast.error('Failed to revoke access for the selected bc user!');
    } finally {
      setLoaders(prev => ({ ...prev, [`bc-user-revoke-${id}`]: false }));
    }
  };

  // Helper for rendering chips
  const renderChips = (assigned: Access[], type: string) =>
    assigned.map(access => (
      <div
        key={access.ID}
        className={`ui-chips-input-token ${styles['chips-custom']}${access.inherited ? ' success-chip' : ''}`}
      >
        {access.IDENTIFICATOR || access.NAME}
        {!access.inherited ? (
          <>
            {!loaders[`${type}-revoke-${access.ID}`] ? (
              <i
                className="ml-2 cursor-pointer fa fa-times"
                title={`Revoke access for this ${type}!`}
                onClick={() => {
                  if (type === 'group') onRemoveGroupAccess(access.ID);
                  if (type === 'individual') onRemoveIndividualAccess(access.ID);
                  if (type === 'bc-user') onRemoveBcUserAccess(access.ID);
                }}
              />
            ) : (
              <i
                className="ml-2 fa fa-spin fa-spinner"
                title={`Revoking access for this ${type}!`}
              />
            )}
          </>
        ) : (
          <i
            className="ml-2 far fa-question-circle"
            title="This access is inherited from its parent, can't be modified here!"
          />
        )}
      </div>
    ));

  return (
    <section className="bg-white pb-3 pl-3 pr-3">
      <div className="grid">
        <div className='col-12'>
          <Fieldset legend="Access Management">
            {/* Group Access */}
            <div className="grid align-items-center mb-4">
              <div className="col-3">
                <p className="p-label">
                  Group <span className="marker_required">*</span> :
                </p>
              </div>
              <div className="col-6">
                <div className="flex align-items-center">
                  <Dropdown
                    options={filteredGroupAccess}
                    className="mr-2 w-full"
                    optionLabel="IDENTIFICATOR"
                    value={selectedGroup}
                    onChange={e => setSelectedGroup(e.value)}
                    onClick={filterGroups}
                    placeholder="Choose group access"
                  />
                  <span
                    className="tooltip-wrapper"
                    data-pr-tooltip="Assign action access to the selected group"
                  >
                    <Button
                      icon="pi pi-plus"
                      aria-label="add"
                      className="my-group-plus-btn"
                      onClick={onAssignGroupAccess}
                      disabled={!selectedGroup}
                    />
                  </span>

                  <Tooltip target=".tooltip-wrapper" position="right" />
                  {/* <Button
                    icon="pi pi-plus"
                    aria-label='add'
                    className="my-group-plus-btn"
                    tooltip="Assign action access to the selected group"
                    tooltipOptions={{ position: 'right' }}
                    onClick={onAssignGroupAccess}
                    disabled={!selectedGroup}
                  /> */}
                </div>
                <div className="p-grid mt-2">
                  <div className={`${styles['chips-wrapper']}`}>
                    {(loaders['group-load'] || errors['group-load']) ? (
                      <>
                        {loaders['group-load'] && (
                          <p className="p-2 mt-2">
                            <i className="fa fa-spin fa-spinner mr-2"></i> loading assigned group accesses
                          </p>
                        )}
                        {errors['group-load'] && (
                          <p className="error-message p-2 mt-2">
                            <i className="fas fa-exclamation-triangle mr-2"></i>
                            {errors['group-load'].message}. Please
                            <a className="font-bold cursor-pointer" onClick={loadGroupAccesses}>Retry!</a>
                          </p>
                        )}
                      </>
                    ) : (
                      renderChips(assignedGroupAccess, 'group')
                    )}
                  </div>
                </div>
              </div>
              <div className="col-3">
                {loaders['group'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> loading available groups
                  </p>
                )}
                {loaders['group-assign'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> saving the group assignment
                  </p>
                )}
              </div>
            </div>
            {/* Individual Access */}
            <div className="grid align-items-center mb-4">
              <div className="col-3">
                <p className="p-label">
                  Individual <span className="marker_required">*</span> :
                </p>
              </div>
              <div className="col-6">
                <div className="flex align-items-center">
                  <Dropdown
                    options={filteredIndividualAccess}
                    className="mr-2 w-full"
                    optionLabel="NAME"
                    value={selectedIndividual}
                    onChange={e => setSelectedIndividual(e.value)}
                    onClick={filterIndividuals}
                    placeholder="Choose individual access"
                  />
                  <span
                    className="my-group-plus-btn-tooltip"
                    data-pr-tooltip="Assign action access to the selected individual"
                  >
                    <Button
                      icon="pi pi-plus"
                      className="my-group-plus-btn"
                      onClick={onAssignIndividualAccess}
                      disabled={loaders.individual || loaders['individual-assign'] || !selectedIndividual}
                    />
                  </span>
                  <Tooltip target=".my-group-plus-btn-tooltip" position="right" />
                  {/* <Button
                      className="ui-button"
                      tooltip="Assign action access to the selected individual"
                      onClick={onAssignIndividualAccess}
                      disabled={loaders.individual || loaders['individual-assign'] || !selectedIndividual}
                      icon={loaders['individual-assign'] ? 'pi pi-spin pi-spinner' : 'fa fa-plus'}
                    /> */}
                </div>
                <div className="p-grid mt-2">
                  <div className={`${styles['chips-wrapper']}`}>
                    {(loaders['individual-load'] || errors['individual-load']) ? (
                      <>
                        {loaders['individual-load'] && (
                          <p className="p-2 mt-2">
                            <i className="fa fa-spin fa-spinner mr-2"></i> loading assigned individual accesses
                          </p>
                        )}
                        {errors['individual-load'] && (
                          <p className="error-message p-2 mt-2">
                            <i className="fas fa-exclamation-triangle mr-2"></i>
                            {errors['individual-load'].message}. Please
                            <a className="font-bold cursor-pointer" onClick={loadIndividualAccesses}>Retry!</a>
                          </p>
                        )}
                      </>
                    ) : (
                      renderChips(assignedIndividualAccess, 'individual')
                    )}
                  </div>
                </div>
              </div>
              <div className="col-3">
                {loaders['individual'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> loading available individuals
                  </p>
                )}
                {loaders['individual-assign'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> saving the individual assignment
                  </p>
                )}
              </div>
            </div>
            {/* BC User Access */}
            <div className="grid align-items-center mb-4">
              <div className="col-3">
                <p className="p-label">
                  Business Center <span className="marker_required">*</span> :
                </p>
              </div>
              <div className="col-6">
                <div className="flex align-items-center">
                  <Dropdown
                    options={filteredBcUserAccess}
                    className="mr-2 w-full"
                    optionLabel="NAME"
                    value={selectedBcUser}
                    onChange={e => setSelectedBcUser(e.value)}
                    onClick={filterBcCustomers}
                    placeholder="Choose bc user access"
                  />
                   <span
                    className="my-group-plus-btn-tooltip"
                    data-pr-tooltip="Assign action access to the selected individual">

                    <Button
                      className='my-group-plus-btn'
                      tooltip="Assign action access to the selected bc user"
                      onClick={onAssignBcUserAccess}
                      disabled={loaders['bc-user'] || loaders['bc-user-assign'] || !selectedBcUser}
                      icon={loaders['bc-user-assign'] ? 'pi pi-spin pi-spinner' : "pi pi-plus"}
                    /> 
                  </span>
                  <Tooltip target=".my-group-plus-btn-tooltip" position="right" />
                  {/* <Button
                    className='my-group-plus-btn'
                    tooltip="Assign action access to the selected bc user"
                    onClick={onAssignBcUserAccess}
                    disabled={loaders['bc-user'] || loaders['bc-user-assign'] || !selectedBcUser}
                    icon={loaders['bc-user-assign'] ? 'pi pi-spin pi-spinner' : "pi pi-plus"}
                  /> */}
                </div>
                <div className="p-grid mt-2">
                  <div className={`${styles['chips-wrapper']}`}>
                    {(loaders['bc-user-load'] || errors['bc-user-load']) ? (
                      <>
                        {loaders['bc-user-load'] && (
                          <p className="p-2 mt-2">
                            <i className="fa fa-spin fa-spinner mr-2"></i> loading assigned bc user accesses
                          </p>
                        )}
                        {errors['bc-user-load'] && (
                          <p className="error-message p-2 mt-2">
                            <i className="fas fa-exclamation-triangle mr-2"></i>
                            {errors['bc-user-load'].message}. Please
                            <a className="font-bold cursor-pointer" onClick={loadBcUserAccesses}>Retry!</a>
                          </p>
                        )}
                      </>
                    ) : (
                      renderChips(assignedBcUserAccess, 'bc-user')
                    )}
                  </div>
                </div>
              </div>
              <div className="col-3">
                {loaders['bc-user'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> loading available bc users
                  </p>
                )}
                {loaders['bc-user-assign'] && (
                  <p className="p-2 ml-2">
                    <i className="fa fa-spin fa-spinner"></i> saving the bc user assignment
                  </p>
                )}
              </div>
            </div>
          </Fieldset>
        </div>
      </div>
    </section>
  );
};


export default ActionAccess;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\components\actions\actionPropertiesForm.tsx
"use client";
 
import React, { useEffect, useMemo, useState } from "react";
import styles from "./actionProperties.module.css";
import {
  getCustomers,
  getServices,
  getVendors,
  getActionTypes,
  getHostnames,
  getRollbackTimers,
  getWorkflowAttributes,
  saveAction,
} from "../../services/controllerService"; // <-- keep this path as in your repo
 
type CustomerType = { id: string; name: string };
type Option = { id?: string | number; name?: string; serviceName?: string; vendorType?: string; ID?: number; NAME?: string };
type WorkflowAttributes = {
  validation: { required: boolean; enabled: boolean };
  hostname: { required: boolean; enabled: boolean };
  configurationTemplate: { required: boolean; enabled: boolean };
  apiEndpoint: { required: boolean; enabled: boolean };
};
 
const DEFAULT_WORKFLOW_ATTRIBUTES: WorkflowAttributes = {
  validation: { required: false, enabled: true },
  hostname: { required: false, enabled: false },
  configurationTemplate: { required: false, enabled: true },
  apiEndpoint: { required: false, enabled: true },
};
 
const initialFormFactory = (customersFirstId = "") => ({
  actionName: "",
  customer: customersFirstId,
  service: "",
  actionType: "",
  staticHost: false,
  hostname: "",
  description: "",
  enabled: false,
  vendor: "",
  configTemplate: "",
  reportPath: "/api/report",
  minRollbackTimer: "",
  maxRollbackTimer: "",
});
 
interface ActionPropertiesFormProps {
  selectionType: string;
  selectionId: string;
}

export default function ActionPropertiesForm({ selectionType, selectionId }: ActionPropertiesFormProps) {
  // Data lists
  const [customers, setCustomers] = useState<CustomerType[]>([]);
  const [services, setServices] = useState<Option[]>([]);
  const [vendors, setVendors] = useState<Option[]>([]);
  const [actionTypes, setActionTypes] = useState<Option[]>([]);
  const [hostnames, setHostnames] = useState<string[]>([]);
  const [rollbackTimers, setRollbackTimers] = useState<number[]>([]);
  const [workflowAttributes, setWorkflowAttributes] = useState<WorkflowAttributes>(DEFAULT_WORKFLOW_ATTRIBUTES);
 
  // Form state
  const [form, setForm] = useState(() => initialFormFactory());
  const [original, setOriginal] = useState(() => initialFormFactory());
  const [loading, setLoading] = useState(false);
 
  // UI helpers
  const [errors, setErrors] = useState<Record<string, string>>({});
 
  // Hardcoded config templates (you can swap this for API-driven)
  const configTemplateOptions = useMemo(
    () => [
      { id: "my_new_template_adding", name: "my_new_template_adding" },
      { id: "my_test_junos", name: "my_test_junos" },
    ],
    []
  );
 
  // load initial dropdown data
  useEffect(() => {
    let isMounted = true;
    (async () => {
      try {
        setLoading(true);
        const customersRes = (await getCustomers()) || [];
        if (!isMounted) return;

        setCustomers(customersRes);
        // If selectionType is 'customer' or 'service', use selectionId to fetch dependent lists
        const selectedCustomerId = selectionType === "customer" ? selectionId : customersRes?.[0]?.id ?? "";

        const [servicesRes, vendorsRes, actionTypesRes, hostnamesRes, rollbackTimersRes] = await Promise.all([
          getServices(),
          getVendors(),
          getActionTypes(),
          getHostnames(selectedCustomerId),
          getRollbackTimers(),
        ]);

        if (!isMounted) return;

        setServices(Array.isArray(servicesRes) ? servicesRes : []);
        setVendors(Array.isArray(vendorsRes) ? vendorsRes : []);
        setActionTypes(Array.isArray(actionTypesRes) ? actionTypesRes : []);
        setHostnames(Array.isArray(hostnamesRes) ? hostnamesRes.map((h: any) => h.HOSTNAME ?? h) : []);
        setRollbackTimers(Array.isArray(rollbackTimersRes) ? rollbackTimersRes : []);

        // initialize form.customer to the selected customer (if not already set)
        setForm((prev) => {
          const next = { ...prev, customer: prev.customer || selectedCustomerId };
          setOriginal(next);
          return next;
        });
      } catch (err) {
        console.error("Error loading dropdowns:", err);
      } finally {
        if (isMounted) setLoading(false);
      }
    })();

    return () => {
      isMounted = false;
    };
  }, [selectionType, selectionId]);
 
  // reload hostnames when customer selection changes
  useEffect(() => {
    let isMounted = true;
    const cid = form.customer;
    if (!cid) return;
    (async () => {
      try {
        const hostRes = await getHostnames(cid);
        if (!isMounted) return;
        setHostnames(Array.isArray(hostRes) ? hostRes.map((h: any) => h.HOSTNAME ?? h) : []);
      } catch (err) {
        console.error("Failed loading hostnames for customer:", cid, err);
      }
    })();
    return () => {
      isMounted = false;
    };
  }, [form.customer]);
 
  // load workflow attributes when actionType changes
  useEffect(() => {
    let isMounted = true;
    if (!form.actionType) {
      setWorkflowAttributes(DEFAULT_WORKFLOW_ATTRIBUTES);
      return;
    }
    (async () => {
      try {
        const attrs = await getWorkflowAttributes(form.actionType);
        if (!isMounted) return;
        setWorkflowAttributes(attrs || DEFAULT_WORKFLOW_ATTRIBUTES);
      } catch (err) {
        console.error("Error loading workflow attributes:", err);
        setWorkflowAttributes(DEFAULT_WORKFLOW_ATTRIBUTES);
      }
    })();
    return () => {
      isMounted = false;
    };
  }, [form.actionType]);
 
  // generic change handler (works for inputs, selects, textareas, checkbox)
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type, checked } = e.target as HTMLInputElement;
    setForm((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
 
    // clear error for this field
    setErrors((prev) => ({ ...prev, [name]: "" }));
  };
 
  const handleReset = () => {
    setForm({ ...original });
    setErrors({});
  };
 
  const validate = () => {
    const newErrors: Record<string, string> = {};
    if (!form.actionName || !form.actionName.trim()) newErrors.actionName = "Action Name is required";
    if (!form.service) newErrors.service = "Service is required";
    if (!form.actionType) newErrors.actionType = "Action Type is required";
    if (!form.description || !form.description.trim()) newErrors.description = "Description is required";
    if (!form.vendor) newErrors.vendor = "Vendor is required";
    if (!form.configTemplate) newErrors.configTemplate = "Config Template is required";
 
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
 
  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    if (!validate()) return;
    setLoading(true);
 
    try {
      // prepare payload as your backend expects — adjust encoding/field names if required
      const payload = {
        name: form.actionName,
        customer: form.customer,
        service: form.service,
        actionType: form.actionType,
        staticHost: Boolean(form.staticHost),
        hostname: form.hostname || undefined,
        description: form.description,
        enabled: Boolean(form.enabled),
        vendor: form.vendor,
        configTemplate: form.configTemplate,
        reportPath: form.reportPath,
        minRollbackTimer: form.minRollbackTimer,
        maxRollbackTimer: form.maxRollbackTimer,
      };
 
      const res = await saveAction(payload);
      // if backend returns the new/saved object, consider updating original
      setOriginal({ ...form });
      // success feedback (replace with toast if you use one)
      alert("Action saved successfully");
      return res;
    } catch (err) {
      console.error("Error saving action:", err);
      alert("Save failed. See console for details.");
      throw err;
    } finally {
      setLoading(false);
    }
  };
 
  return (
    <form className={styles["form-container"]} onSubmit={handleSubmit}>
      <h2 className={styles["form-title"]}>Action Properties</h2>
 
      {/* Action Name */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Action Name <span className={styles["required"]}>*</span></label>
        <input name="actionName" value={form.actionName} onChange={handleChange} className={styles["form-input"]} />
        {errors.actionName && <div className={styles["error-text"]}>{errors.actionName}</div>}
      </div>
 
      {/* Customer */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Customer Name</label>
        <select name="customer" value={form.customer} onChange={handleChange} className={styles["form-input"]}>
          <option value="">-- Select Customer --</option>
          {customers.map((c) => <option key={c.id} value={c.id}>{c.name}</option>)}
        </select>
      </div>
 
      {/* Service */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Service <span className={styles["required"]}>*</span></label>
        <select name="service" value={form.service} onChange={handleChange} className={styles["form-input"]}>
          <option value="">-- Select Service --</option>
          {services.map((s: any, i) => (
            <option key={(s.id ?? s.ID ?? i).toString()} value={s.id ?? s.ID ?? s.serviceId ?? s.id}>
              {s.serviceName ?? s.name ?? s.NAME}
            </option>
          ))}
        </select>
        {errors.service && <div className={styles["error-text"]}>{errors.service}</div>}
      </div>
 
      {/* Action Type */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Action Type <span className={styles["required"]}>*</span></label>
        <select name="actionType" value={form.actionType} onChange={handleChange} className={styles["form-input"]}>
          <option value="">-- Select Action Type --</option>
          {actionTypes.map((a: any, i) => (
            <option key={(a.ID ?? a.id ?? i).toString()} value={a.ID ?? a.id ?? a.ID}>
              {a.NAME ?? a.name}
            </option>
          ))}
        </select>
        {errors.actionType && <div className={styles["error-text"]}>{errors.actionType}</div>}
      </div>
 
      {/* Static Host */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Static Host</label>
        <input name="staticHost" type="checkbox" checked={Boolean(form.staticHost)} onChange={handleChange} />
      </div>
 
      {/* Hostname (only if staticHost or workflow requires enable) */}
      {(form.staticHost || workflowAttributes.hostname.enabled) && (
        <div className={styles["form-row"]}>
          <label className={styles["form-label"]}>Hostname</label>
          <select name="hostname" value={form.hostname} onChange={handleChange} className={styles["form-input"]}>
            <option value="">-- Select Hostname --</option>
            {hostnames.map((h, i) => <option key={i} value={h}>{h}</option>)}
          </select>
        </div>
      )}
 
      {/* Description */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Description <span className={styles["required"]}>*</span></label>
        <textarea name="description" value={form.description} onChange={handleChange} className={styles["form-input"]} />
        {errors.description && <div className={styles["error-text"]}>{errors.description}</div>}
      </div>
 
      {/* Enabled */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Enabled</label>
        <input name="enabled" type="checkbox" checked={Boolean(form.enabled)} onChange={handleChange} />
      </div>
 
      {/* Vendor */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Vendor <span className={styles["required"]}>*</span></label>
        <select name="vendor" value={form.vendor} onChange={handleChange} className={styles["form-input"]}>
          <option value="">-- Select Vendor --</option>
          {vendors.map((v: any, i) => <option key={(v.id ?? i).toString()} value={v.id}>{v.vendorType ?? v.name}</option>)}
        </select>
        {errors.vendor && <div className={styles["error-text"]}>{errors.vendor}</div>}
      </div>
 
      {/* Config Template */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Configuration Template <span className={styles["required"]}>*</span></label>
        <select name="configTemplate" value={form.configTemplate} onChange={handleChange} className={styles["form-input"]}>
          <option value="">-- Select Template --</option>
          {configTemplateOptions.map((t) => <option key={t.id} value={t.id}>{t.name}</option>)}
        </select>
        {errors.configTemplate && <div className={styles["error-text"]}>{errors.configTemplate}</div>}
      </div>
 
      {/* Rollback timers */}
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Min Rollback Timer</label>
        <input name="minRollbackTimer" type="number" value={form.minRollbackTimer} onChange={handleChange} className={styles["form-input"]} />
      </div>
      <div className={styles["form-row"]}>
        <label className={styles["form-label"]}>Max Rollback Timer</label>
        <input name="maxRollbackTimer" type="number" value={form.maxRollbackTimer} onChange={handleChange} className={styles["form-input"]} />
      </div>
 
      {/* Buttons */}
      <div className={styles["button-row"]} style={{ display: "flex", gap: 12 }}>
        <button type="button" className={styles["reset-btn"]} onClick={handleReset} disabled={loading}>
          ⟳ Reset Original
        </button>
 
        <button type="submit" className={styles["save-btn"]} disabled={loading}>
          {loading ? "Saving..." : "💾 Save Changes"}
        </button>
      </div>
    </form>
  );
}


C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\components\controllerService.ts
// ----------------- Customers -----------------
export async function getCustomers() {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/customers/status/?active=true`, {
    cache: "no-store", // ensure fresh data
  });
  if (!res.ok) throw new Error("Failed to fetch customers");
  const json = await res.json();
  return json.result; // backend returns { result: [...] }
}
 
// ----------------- Services -----------------
export async function getServices(customerId: string) {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/service?customerId=${customerId}`, {
    cache: "no-store",
  });
  if (!res.ok) throw new Error("Failed to fetch services");
  const json = await res.json();
  return json.result;
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\components\navbar.tsx
"use client";

import React, { useEffect, useState, useRef } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { getCustomers } from "./controllerService";
import styles from "./navbar.module.css";

interface Customer {
  id: string;
  name: string;
}

const Navbar: React.FC = () => {
  const pathname = usePathname();
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [selected, setSelected] = useState<string>("");
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [search, setSearch] = useState("");
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    getCustomers()
      .then(setCustomers)
      .catch((err) => console.error("Failed to fetch customers:", err));
  }, []);

  // Close dropdown on outside click
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setDropdownOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const filteredCustomers = customers.filter(c =>
    c.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <nav className={styles.navbar} style={{
      background: "#000",
      color: "#fff",
      display: "flex",
      alignItems: "center",
      padding: "0 20px",
      height: "65px"
    }}>
      {/* Logo */}
      <div className={styles.logo} style={{ display: "flex", alignItems: "center", marginRight: "24px" }}>
        <img src="/logo3.original.png" alt="one" style={{ height: "32px", marginRight: "8px" }} />
        <span style={{ fontWeight: "bold", fontSize: "1.2em" }}></span>
      </div>
      {/* Custom Dropdown */}
      <div ref={dropdownRef} style={{ position: "relative", marginRight: "32px" }}>
        <button
          onClick={() => setDropdownOpen((v) => !v)}
          style={{
            background: "#fff",
            color: "#000",
            border: "none",
            borderRadius: "4px",
            padding: "6px 12px",
            minWidth: "180px",
            textAlign: "left",
            fontSize: "1em",
            cursor: "pointer"
          }}
        >
          {selected
            ? customers.find((c) => c.id === selected)?.name
            : "Select Customer"}
        </button>
        {dropdownOpen && (
          <div
            style={{
              position: "absolute",
              top: "110%",
              left: 0,
              background: "#fff",
              color: "#000",
              border: "1px solid #ccc",
              borderRadius: "4px",
              width: "260px",
              zIndex: 10,
              boxShadow: "0 2px 8px rgba(0,0,0,0.15)"
            }}
          >
            <div style={{ display: "flex", alignItems: "center", padding: "8px" }}>
              <input
                type="text"
                placeholder="Search"
                value={search}
                onChange={e => setSearch(e.target.value)}
                style={{
                  flex: 1,
                  padding: "4px 8px",
                  border: "1px solid #ccc",
                  borderRadius: "4px"
                }}
              />
              <span style={{ marginLeft: "4px", color: "#888" }}>🔍</span>
            </div>
            <div style={{
              maxHeight: "180px",
              overflowY: "auto",
              borderTop: "1px solid #eee"
            }}>
              {filteredCustomers.length === 0 && (
                <div style={{ padding: "8px", color: "#888" }}>No customers</div>
              )}
              {filteredCustomers.map((c) => (
                <button
                  key={c.id}
                  type="button"
                  onClick={() => {
                    setSelected(c.id);
                    setDropdownOpen(false);
                    localStorage.setItem("selectedCustomer", c.id);
                    window.dispatchEvent(new Event("customerChanged"));
                  }}
                  style={{
                    padding: "8px 12px",
                    cursor: "pointer",
                    background: c.id === selected ? "#e6f7ff" : "#fff",
                    border: "none",
                    width: "100%",
                    textAlign: "left"
                  }}
                >
                  {c.name}
                </button>
              ))}

            </div>
          </div>
        )}
      </div>
      {/* Links */}
      <div style={{ display: "flex", gap: "24px" }}>
        {[
          { href: "/actions", label: "Actions" },
          { href: "/configurationTemplate", label: "Configuration Templates" },
          { href: "/adminUI", label: "Administration UI" },
          { href: "/monitor", label: "Monitor" },
          { href: "/config-audit", label: "Configuration Audit" },
          { href: "/access-control", label: "Access Control" },
        ].map(({ href, label }) => (
          <Link
            key={href}
            href={href}
            style={{
              color: pathname === href ? "#5db1f6ff" : "#fff",
              textDecoration: "none",
              fontWeight: pathname === href ? "bold" : "normal",
              borderBottom: pathname === href ? "2px solid #61b5fa" : "none",
              padding: "4px 8px",
              borderRadius: "4px",
              transition: "transform 0.15s, background 0.15s",
              background: pathname === href ? "#f1f8fe" : "transparent",
              transform: pathname === href ? "scale(1.05)" : "none",
            }}
            onMouseEnter={e => {
              // (e.currentTarget as HTMLElement).style.background = "#e6f7ff";
              (e.currentTarget as HTMLElement).style.transform = "scale(1.07)";
            }}
            onMouseLeave={e => {
              (e.currentTarget as HTMLElement).style.background = pathname === href ? "#f1f8fe" : "transparent";
              (e.currentTarget as HTMLElement).style.transform = pathname === href ? "scale(1.05)" : "none";
            }}
          >
            {label}
          </Link>
        ))}
      </div>
    </nav>
  );
};

export default Navbar;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\configurationTemplate\editor\editor.tsx
"use client";
import React, { useEffect } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Button, Typography, Space, Card, Modal, Table, Select } from "antd";
import { ExclamationCircleOutlined } from "@ant-design/icons";
import dynamic from "next/dynamic";
import TemplateApi, { TemplateResponse, VariableResponse, } from "../../../services/apiConnectService";
import { toast } from "react-toastify";

export interface Template {
    contractid: string | null;
    service: string | null;
    name: string;
    id: string | number;
}

interface EditorProps {
    template?: Template;
    onEventSpinner?: (status: boolean) => void;
    onCopiedTemplate?: (data: any) => void;
    onDeleteTemplate?: (data: any) => void;
    onSpinnerStatus?: (status: boolean) => void;
}
// dynamic Ace import — load ace core and mode/theme first
const AceEditor = dynamic(async () => {
    await import("ace-builds/src-noconflict/ace");
    await import("ace-builds/src-noconflict/ext-language_tools");
    await import("ace-builds/src-noconflict/mode-django");
    await import("ace-builds/src-noconflict/theme-github");
    const mod = await import("react-ace");
    return mod.default;
}, { ssr: false });

const { Title, Text } = Typography;
const { Option } = Select;

const Editor: React.FC<EditorProps> = ({ template, onEventSpinner }) => {
    const qc = useQueryClient();
    const contentTypesQuery = useQuery({
        queryKey: ["contentTypes"],
        queryFn: () => TemplateApi.contentTypes(),
    });
    const templateTypesQuery = useQuery({
        queryKey: ["templateTypes"],
        queryFn: () => TemplateApi.templateTypes(),
    });
    const vendorTypesQuery = useQuery({
        queryKey: ["vendorTypes"],
        queryFn: () => TemplateApi.vendorTypes(),
    });
    // templates list by contract/service
    const templatesQuery = useQuery({
        queryKey: ["templates", template?.contractid ?? "", template?.service ?? "", template?.name ?? ""],
        queryFn: () => TemplateApi.listTemplates(template?.contractid ?? undefined, template?.service ?? undefined),
        enabled: !!(template?.contractid || template?.service),
        placeholderData: [],
    });
    useEffect(() => {
        if (templatesQuery.isLoading) {
            onEventSpinner?.(true);
        } else {
            onEventSpinner?.(false);
        }
    }, [templatesQuery.isLoading]);
    const templates = templatesQuery.data ?? [];

    const [selected, setSelected] = React.useState<TemplateResponse | null>(null);
    const [editorValue, setEditorValue] = React.useState<string>("");
    const [isEditing, setIsEditing] = React.useState<boolean>(false);
    const [loading, setLoading] = React.useState<boolean>(false);
    const [saveConfirmOpen, setSaveConfirmOpen] = React.useState<boolean>(false);
    const [variableModalOpen, setVariableModalOpen] = React.useState(false);
    const [copyModalOpen, setCopyModalOpen] = React.useState(false);
    const [copiedTemplateName, setCopiedTemplateName] = React.useState("");
    const [variables, setVariables] = React.useState<VariableResponse | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = React.useState<boolean>(false);

    // metadata dropdowns state
    const [selectedContentType, setSelectedContentType] = React.useState<number | null>(null);
    const [selectedTemplateType, setSelectedTemplateType] = React.useState<number | null>(null);
    const [selectedVendorType, setSelectedVendorType] = React.useState<number | null>(null);

    // state variables for jinja conversion
    const [jinjaModalOpen, setJinjaModalOpen] = React.useState(false);
    const [jinjaFullscreen, setJinjaFullscreen] = React.useState(false);
    const [convertedJinja, setConvertedJinja] = React.useState("");
    const [jinjaTemplateName, setJinjaTemplateName] = React.useState("");

    // When templates load, pick first (As in Angular default behaviour)
    useEffect(() => {
        if (!selected && templates && templates.length > 0) {
            setSelected(templates[0]);
            setEditorValue(templates[0].body ?? "");
            setSelectedContentType(Number(templates[0].deviceModel ?? 0) || null);
            setSelectedTemplateType(Number(templates[0].templateType ?? 0) || null);
            setSelectedVendorType(Number(templates[0].vendorType ?? 0) || null);
        }

        if (templates && templates.length === 0) {
            setSelected(null);
            setEditorValue("");
            setIsEditing(false);
        }
    }, [templates]);
    useEffect(() => {
        const fetchTemplate = async () => {
            if (!template || !onEventSpinner) {
                // if no template selected, clear editor
                setSelected(null);
                setEditorValue("");
                setIsEditing(false);
                return;
            }
            setLoading(true);
            try {
                onEventSpinner(true);
                // fetch full template details (like Angular)
                const tpl = await TemplateApi.getTemplateByName(
                    template.name,
                    template.contractid ?? undefined,
                    template.service ?? undefined
                );
                if (tpl) {
                    setSelected(tpl as any);
                    setEditorValue((tpl as any).body ?? "");
                    setSelectedContentType(Number((tpl as any).deviceModel ?? 0) || null);
                    setSelectedTemplateType(Number((tpl as any).templateType ?? 0) || null);
                    setSelectedVendorType(Number((tpl as any).vendorType ?? 0) || null);
                } else {
                    setSelected({
                        id: template.id as any,
                        name: template.name,
                        contractid: template.contractid ?? undefined,
                        services: template.service ?? undefined,
                        body: "",
                    } as any);
                    setEditorValue("");
                }
            } catch (err) {
                toast.error("Unable to fetch selected template details");
            } finally {
                // hide spinner
                onEventSpinner(false);
                setLoading(false);
            }
        };
        fetchTemplate();
    }, [template?.id, template?.name, template?.contractid, template?.service]);
    // Save (update)
    const handleSave = async (): Promise<any> => {
        if (!selected) throw new Error("No template selected");
        const payload: Partial<TemplateResponse> & { id: number } = {
            id: Number(selected.id),
            name: selected.name,
            body: btoa(convertedJinja),
            contractid: selected.contractid ? String(selected.contractid) : undefined,
            deviceModel: selectedContentType ? Number(selectedContentType) : undefined,
            templateType: selectedTemplateType ? Number(selectedTemplateType) : undefined,
            vendorType: selectedVendorType ? Number(selectedVendorType) : undefined,
        };
        if (selected.service) {
            payload.service = String(selected.service);
        }
        try {
            const res = await TemplateApi.updateTemplate(payload);
            console.log(">>>>>>>>>>>>>>>> updateTemplate response:", res);
            toast.success("Template saved");
            setIsEditing(false);
            await qc.invalidateQueries({ queryKey: ["templates", template?.contractid ?? "", template?.service ?? ""] });
            return res; // <--- important: return so caller can await & react
        } catch (err: any) {
            toast.error(`Save failed: ${err?.message ?? err}`);
            throw err;
        }
    };
    // Show confirmation modal before saving. Calls handleSave() if user confirms.
    const confirmAndSave = () => {
        if (!selected) {
            toast.error("No template selected");
            return;
        }
        Modal.confirm({
            title: "Save confirmation",
            icon: <ExclamationCircleOutlined />,
            content: "Do you want to save changes to this template?",
            okText: "Yes",
            cancelText: "No",
            centered: true,
            okType: "primary",
            // return the promise returned by handleSave so Antd knows to wait
            onOk() {
                console.log(">>>>>>>>>>>>>>>> inside onOk()");
                setLoading(true);
                return handleSave()
                    .catch((err: any) => {
                        console.log(">>>>>>>>>>>>>>>> onOk handleSave ERROR :", err);
                        toast.error(`Save failed: ${err?.message ?? err}`);
                    })
                    .finally(() => {
                        console.log(">>>>>>>>>>>>>>>> onOk finally reached");
                        setLoading(false);
                    });
            },
            onCancel: () => {
                console.log(">>>>>>>>>>>>>>>> Save cancelled by user");
            },
        });
    };

    // Delete
    const handleDelete = () => {
        if (!selected) return;
        Modal.confirm({
            title: null,
            footer: null,
            centered: true,
            width: 370,
            className: 'blur-modal',
            maskStyle: { backdropFilter: 'blur(4px)' },
            content: (
                <div style={{ borderRadius: 12, overflow: 'hidden', background: '#fff', boxShadow: '0 4px 24px rgba(0,0,0,0.12)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '16px 18px 8px 18px', borderBottom: '1px solid #eee' }}>
                        <span style={{ fontWeight: 600, fontSize: 17 }}>Delete confirmation</span>
                        <span style={{ fontSize: 18, fontWeight: 600, color: '#666', cursor: 'pointer' }} onClick={() => Modal.destroyAll()}>&times;</span>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', padding: '18px 18px 0 18px' }}>
                        <ExclamationCircleOutlined style={{ color: '#faad14', fontSize: 22, marginRight: 12 }} />
                        <span style={{ fontSize: 16 }}>
                            Are you sure that you want to delete this template?
                        </span>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: 8, padding: '18px' }}>
                        <Button
                            type="primary"
                            icon={<i className="pi pi-check" style={{ marginRight: 4 }}></i>}
                            style={{ background: '#1890ff', border: 'none', minWidth: 80 }}
                            onClick={async () => {
                                try {
                                    console.log('Delete button clicked. Selected:', selected);
                                    // Check usage before deleting
                                    const usage = await TemplateApi.checkTemplateUsage?.(selected.id, selected.name);
                                    if (usage && usage.length > 0) {
                                        const actions = usage.map((a: any) => a.NAME).join(', ');
                                        toast.error(`This template cannot be removed, because it is used in: ${actions}. Please remove or change it.`);
                                        return;
                                    }
                                    console.log('Calling deleteTemplate API with:', { id: selected.id });
                                    const res = await TemplateApi.deleteTemplate({ id: selected.id });
                                    console.log('Delete API response:', res);
                                    toast.success('Your template is successfully deleted!');
                                    setSelected(null);
                                    setEditorValue('');
                                    qc.invalidateQueries({ queryKey: ["templates", template?.contractid ?? "", template?.service ?? ""] });
                                    Modal.destroyAll();
                                } catch (err) {
                                    console.error('Delete error:', err);
                                    toast.error('Your template is not deleted!');
                                }
                            }}
                        >
                            Yes
                        </Button>
                        <Button
                            type="default"
                            icon={<i className="pi pi-times" style={{ marginRight: 4 }}></i>}
                            style={{ background: '#1890ff', color: '#fff', border: 'none', minWidth: 80 }}
                            onClick={() => { toast.info('Delete cancelled'); Modal.destroyAll(); }}
                        >
                            No
                        </Button>
                    </div>
                </div>
            ),
        });
    };
    // Copy modal logic
    const handleCopy = () => {
        setCopiedTemplateName(selected ? `${selected.name}-copy` : "");
        setCopyModalOpen(true);
    };
    const handleCopyConfirm = async () => {
        if (!selected || !copiedTemplateName.trim()) {
            toast.error("Please enter a valid template name.");
            return;
        }
        try {
            const payload: Partial<TemplateResponse> = {
                name: copiedTemplateName.trim(),
                body: btoa(selected.body ?? ""),
                contractid: selected.contractid ?? undefined,
                service: selected.service ?? undefined,
                deviceModel: selected.deviceModel ? Number(selected.deviceModel) : undefined,
                templateType: selected.templateType ? Number(selected.templateType) : undefined,
                vendorType: selected.vendorType ? Number(selected.vendorType) : undefined,
            };
            const created = await TemplateApi.addTemplate(payload as any);
            toast.success("Template copied");
            setCopyModalOpen(false);
            setCopiedTemplateName("");
            qc.invalidateQueries({ queryKey: ["templates", template?.contractid ?? "", template?.service ?? ""] });
            // Optionally select the new created if API returns it
            if (created && created.id) {
                const list = await TemplateApi.listTemplates(template?.contractid ?? undefined, template?.service ?? undefined);
                const found: TemplateResponse | undefined = (list as TemplateResponse[]).find((x: TemplateResponse) => x.name === copiedTemplateName.trim());
                if (found) {
                    setSelected(found);
                    setEditorValue(found.body ?? "");
                }
            }
        } catch (err: any) {
            toast.error(`Copy failed: ${err?.message ?? err}`);
        }
    };
    // Convert to Jinja
    const handleConvertToJinja = async () => {
        if (!selected || !editorValue) return;
        try {
            setLoading(true);
            const res = await TemplateApi.convertToJinja(editorValue);
            // sanity check
            if (!res) {
                toast.error("Conversion returned empty result from backend during conversion");
                return;
            }
            // Normalize API response (fixes [object Object])
            let convertedText = "";
            if (typeof res === "string") {
                convertedText = res;
            } else if (res?.data && typeof res.data === "string") {
                convertedText = res.data;
            } else if (res?.converted && typeof res.converted === "string") {
                convertedText = res.converted;
            } else if (res?.result && typeof res.result === "string") {
                convertedText = res.result;
            } else {
                convertedText = JSON.stringify(res, null, 2);
            }
            // reformat the escape characters for proper indentation
            const formattedText = convertedText
                .replace(/\\n/g, "\n")
                .replace(/\\t/g, "\t")
                .trim();

            // Prefill name like Angular
            const newName = `${selected.name}_jinja2`;

            setConvertedJinja(formattedText);
            setJinjaTemplateName(newName);
            setJinjaModalOpen(true);
        } catch (err: any) {
            toast.error(`Conversion failed: ${err?.message ?? err}`);
        } finally {
            setLoading(false);
        }
    };
    // View variables — auto picks endpoint
    const handleViewVariables = async () => {
        if (!selected) return;
        try {
            let data: VariableResponse | null = null;
            if (selected.contractid && selected.name && selected.templateType) {
                data = await TemplateApi.getVariablesByContract(selected.name, selected.contractid, String(selected.templateType));
            } else if (selected.service && selected.name && selected.templateType) {
                data = await TemplateApi.getVariablesByService(selected.name, String(selected.service), String(selected.templateType));
            } else if (selected.id && selected.templateType) {
                data = await TemplateApi.getVariablesByTemplateId(String(selected.id), String(selected.templateType));
            }
            if (data) {
                setVariables(data);
                setVariableModalOpen(true);
            } else {
                toast.info("No variables found");
            }
        } catch (err: any) {
            toast.error(`Failed to load variables: ${err?.message ?? err}`);
        }
    };
    // helper to get Jinja2 template type ID or label
    const getJinja2TypeId = (): number | string | undefined => {
        if (!templateTypesQuery.data) return undefined;

        const jinja = (templateTypesQuery.data as any[]).find(
            (t: any) =>
                t.templateType?.toLowerCase().includes("jinja") ||
                t.templateType?.toLowerCase() === "jinja2"
        );
        return jinja ? jinja.id : undefined;
    };
    // UI rendering
    return (
        <div className="grid grid-cols-12 gap-4 h-full">
            {/* right */}
            <div className="col-span-9 flex flex-col h-full">
                {/* top row: dropdowns + action buttons */}
                <Card size="small" className="mb-2">
                    <div className="flex items-center justify-between gap-4">
                        {/* Left: dropdowns */}
                        <div className="flex items-center gap-2">
                            <Select
                                placeholder="Content Type"
                                style={{ width: 180 }}
                                value={selectedContentType ?? undefined}
                                onChange={(v: number | string) => setSelectedContentType(Number(v))}
                                options={Array.isArray(contentTypesQuery.data) ? contentTypesQuery.data.map((ct: any) => ({ value: ct.id, label: ct.contentType })) : []}
                                disabled={!isEditing} // non-editable until Edit or until you want to allow changing metadata
                            />
                            <Select
                                placeholder="Vendor"
                                style={{ width: 180 }}
                                value={selectedVendorType ?? undefined}
                                onChange={(v: number | string) => setSelectedVendorType(Number(v))}
                                options={Array.isArray(vendorTypesQuery.data) ? vendorTypesQuery.data.map((vt: any) => ({ value: vt.id, label: vt.vendorType })) : []}
                                disabled={!isEditing}
                            />
                            <Select
                                placeholder="Template Type"
                                style={{ width: 180 }}
                                value={selectedTemplateType ?? undefined}
                                onChange={(v: number | string) => setSelectedTemplateType(Number(v))}
                                options={Array.isArray(templateTypesQuery.data) ? templateTypesQuery.data.map((tt: any) => ({ value: tt.id, label: tt.templateType })) : []}
                                disabled={!isEditing}
                            />
                        </div>
                        {/* Right: buttons */}
                        <div>
                            <Space>
                                {/* Edit / Save toggle logic */}
                                {!isEditing ? (
                                    <>
                                        {/* Convert to Jinja (green) */}
                                        {selected && selectedTemplateType !== getJinja2TypeId() && (
                                            <Button
                                                type="primary"
                                                onClick={handleConvertToJinja}
                                                style={{ backgroundColor: "#00a859", borderColor: "#00a859" }}
                                            >
                                                <i className="pi pi-cog" style={{ marginRight: 4 }}></i> Convert to Jinja
                                            </Button>
                                        )}
                                        {/* Edit */}
                                        <Button
                                            type="primary"
                                            onClick={() => setIsEditing(true)}
                                            disabled={!selected}
                                        >
                                            <i className="pi pi-pencil" style={{ marginRight: 4 }}></i> Edit
                                        </Button>
                                        {/* Copy */}
                                        <Button
                                            type="primary"
                                            onClick={handleCopy}
                                            disabled={!selected}
                                            icon={<i className="pi pi-copy" style={{ marginRight: 4 }}></i>}
                                            style={{ marginLeft: 3 }}
                                        >
                                            Copy
                                        </Button>
                                        {/* Copy Modal */}
                                        <Modal
                                            open={copyModalOpen}
                                            onCancel={() => setCopyModalOpen(false)}
                                            footer={null}
                                            centered
                                            width={340}
                                            className="blur-modal"
                                            styles={{ body: { padding: 0, borderRadius: 12, boxShadow: '0 4px 24px rgba(0,0,0,0.12)' } }}
                                            maskStyle={{ backdropFilter: 'blur(4px)' }}
                                            closeIcon={<span style={{ fontSize: 18, fontWeight: 600, color: '#666', cursor: 'pointer' }}>&times;</span>}
                                        >
                                            <div style={{ borderRadius: 12, overflow: 'hidden', background: '#fff' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '16px 18px 8px 18px', borderBottom: '1px solid #eee' }}>
                                                    <span style={{ fontWeight: 600, fontSize: 17 }}>Type name of copied template</span>
                                                    <span style={{ fontSize: 18, fontWeight: 600, color: '#666', cursor: 'pointer' }} onClick={() => setCopyModalOpen(false)}>&times;</span>
                                                </div>
                                                <div style={{ padding: '18px 18px 0 18px' }}>
                                                    <label htmlFor="copy-template-name" style={{ color: '#333', fontSize: 14, marginBottom: 6, display: 'block' }}>cArche template name</label>
                                                    <input
                                                        id="copy-template-name"
                                                        type="text"
                                                        value={copiedTemplateName}
                                                        onChange={e => setCopiedTemplateName(e.target.value)}
                                                        maxLength={120}
                                                        placeholder="cArche template name"
                                                        style={{ width: '100%', marginBottom: 0, padding: 8, fontSize: 15, borderRadius: 4, border: '1px solid #d9d9d9' }}
                                                    />
                                                </div>
                                                <div style={{ display: 'flex', justifyContent: 'flex-end', padding: '18px' }}>
                                                    <Button
                                                        type="primary"
                                                        icon={<i className="pi pi-copy" style={{ marginRight: 4 }}></i>}
                                                        style={{ background: '#1890ff', border: 'none', minWidth: 80 }}
                                                        onClick={handleCopyConfirm}
                                                    >
                                                        Copy
                                                    </Button>
                                                </div>
                                            </div>
                                        </Modal>
                                        {/* Delete */}
                                        <Button
                                            type="primary"
                                            danger
                                            onClick={() => setDeleteConfirmOpen(true)}
                                            disabled={!selected}
                                        >
                                            <i className="pi pi-trash" style={{ marginRight: 4 }}></i> Delete
                                        </Button>

                                    </>
                                ) : (
                                    <>
                                        {selected && selectedTemplateType !== getJinja2TypeId() && (
                                            <Button
                                                type="primary"
                                                onClick={handleConvertToJinja}
                                                // disabled={!selected}
                                                style={{ backgroundColor: "#00a859", borderColor: "#00a859" }}
                                            >
                                                <i className="pi pi-cog" style={{ marginRight: 4 }}></i> Convert to Jinja
                                            </Button>
                                        )}

                                        {/* Save replaces Edit */}
                                        <Button
                                            type="primary"
                                            onClick={() => setSaveConfirmOpen(true)}
                                            disabled={!selected || loading}
                                            icon={<i className="pi pi-save" />}
                                        >
                                            Save
                                        </Button>
                                        {/* Keep Copy and Convert still visible */}
                                        <Button
                                            type="primary"
                                            onClick={handleCopy}
                                            disabled={!selected}
                                        >
                                            <i className="pi pi-copy" style={{ marginRight: 4 }}></i> Copy
                                        </Button>
                                        {/* Cancel replaces Delete */}
                                        <Button
                                            type="primary"
                                            onClick={() => setIsEditing(false)}
                                            disabled={!selected}
                                            icon={<i className="pi pi-times" />}
                                        >
                                            Cancel
                                        </Button>
                                    </>
                                )}
                            </Space>
                        </div>
                    </div>
                </Card>
                {/* editor */}
                <div className="flex-1 border rounded-lg overflow-hidden min-h-[60vh] w-full relative">
                    {loading ? (
                        <div className="flex justify-center items-center h-full">
                            <i className="pi pi-spin pi-spinner" style={{ fontSize: "2rem" }}></i>
                        </div>
                    ) : !selected ? (
                        <div className="flex justify-center items-center h-full text-gray-500 italic">
                            Select a template from the left panel to begin editing
                        </div>
                    ) : (
                        <AceEditor
                            mode="django"
                            theme="github"
                            style={{ width: "100%", overflowX: "hidden" }}
                            height="100%"
                            fontSize={14}
                            value={editorValue}
                            onChange={(val: string) => setEditorValue(val)}
                            setOptions={{
                                useWorker: false,
                                showLineNumbers: true,
                                tabSize: 2,
                                enableBasicAutocompletion: true,
                                enableLiveAutocompletion: true,
                            }}
                            readOnly={!isEditing}
                            name="config-template-editor"
                        />
                    )}
                </div>
            </div>
            {/* Variables Modal */}
            <Modal open={variableModalOpen} title="Template Variables" footer={null} onCancel={() => setVariableModalOpen(false)} width={650}>
                {variables ? (
                    <Table
                        size="small"
                        pagination={false}
                        dataSource={Object.entries(variables).map(([k, v]) => ({ key: k, name: k, value: String(v ?? "") }))}
                        columns={[
                            { title: "Variable", dataIndex: "name", key: "name" },
                            { title: "Value", dataIndex: "value", key: "value" },
                        ]}
                    />
                ) : (
                    <Text>No variables found</Text>
                )}
            </Modal>
            {/* Convert to Jinja Modal */}
            <Modal
                open={jinjaModalOpen}
                onCancel={() => setJinjaModalOpen(false)}
                footer={null}
                width={jinjaFullscreen ? "100%" : 800}
                style={jinjaFullscreen ? { top: 0, padding: 0 } : {}}
                className={`jinja-modal ${jinjaFullscreen ? "fullscreen" : ""}`}
                closable={false}
            >
                {/* Header */}
                <div
                    style={{
                        backgroundColor: "#f5f5f5",
                        borderBottom: "1px solid #d9d9d9",
                        padding: "10px 16px",
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                        fontWeight: 600,
                        fontSize: "16px",
                    }}
                >
                    <span>Convert cArche to Jinja2</span>
                    <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
                        {/* Fullscreen toggle */}
                        <i
                            className={`pi ${jinjaFullscreen ? "pi-window-minimize" : "pi-window-maximize"} cursor-pointer text-gray-600 hover:text-black`}
                            title={jinjaFullscreen ? "Exit Fullscreen" : "Fullscreen"}
                            onClick={() => setJinjaFullscreen(!jinjaFullscreen)}
                        ></i>
                        {/* Close */}
                        <i
                            className="pi pi-times cursor-pointer text-gray-600 hover:text-black"
                            onClick={() => setJinjaModalOpen(false)}
                        ></i>
                    </div>
                </div>
                {/* Body */}
                <div style={{ padding: "16px", height: jinjaFullscreen ? "calc(100vh - 60px)" : "auto", overflow: "auto" }}>
                    <p style={{ marginBottom: 12 }}>
                        The respective cArche template has converted successfully to Jinja2 template.
                        <br />
                        <b>Please validate the Jinja2 template before saving it.</b>
                    </p>

                    <div style={{ marginBottom: 12 }}>
                        <label style={{ display: "block", fontWeight: 500 }}>Jinja2 Template Name *</label>
                        <input
                            type="text"
                            value={jinjaTemplateName}
                            onChange={(e) => setJinjaTemplateName(e.target.value)}
                            className="w-full border rounded p-2"
                        />
                    </div>
                    <div style={{ marginBottom: 12 }}>
                        <label style={{ display: "block", fontWeight: 500 }}>Jinja2 Template Content *</label>
                        <textarea
                            value={convertedJinja}
                            onChange={(e) => setConvertedJinja(e.target.value)}
                            spellCheck={false}
                            className="w-full border rounded p-2 font-mono text-sm bg-[#fafafa] resize-none"
                            style={{
                                height: jinjaFullscreen ? "calc(100vh - 300px)" : "300px",
                                whiteSpace: "pre",
                                overflowWrap: "normal",
                                overflowX: "auto",
                            }}
                        />
                    </div>
                    <div className="flex justify-end gap-2 mt-4">
                        <div style={{
                            display: "flex",
                            justifyContent: "flex-end",
                            gap: "10px",
                            marginTop: "16px",
                            borderTop: "1px solid #e0e0e0",
                            paddingTop: "10px"
                        }}
                        >
                            <Button
                                type="primary"
                                style={{
                                    backgroundColor: "#1677ff",
                                    borderColor: "#1677ff",
                                    minWidth: "80px"
                                }}
                                onClick={async () => {
                                    if (!selected) {
                                        toast.error("No template selected");
                                        return;
                                    }
                                    setLoading(true);
                                    try {

                                        const jinjaTypeId = getJinja2TypeId();

                                        // if no Jinja2 type found, stop
                                        if (!jinjaTypeId) {
                                            toast.error("Jinja2 template type not found in dropdown data");
                                            return;
                                        }
                                        // Prepare payload to match Angular
                                        const payload: any = {
                                            name: jinjaTemplateName,
                                            body: btoa(convertedJinja),
                                            contractid: selected.contractid ? String(selected.contractid) : undefined,
                                            deviceModel: selected.deviceModel ? Number(selected.deviceModel) : undefined,
                                            templateType: typeof jinjaTypeId === 'number' ? jinjaTypeId : Number(jinjaTypeId),
                                            vendorType: selected.vendorType ? Number(selected.vendorType) : undefined,
                                        };
                                        // Only add service if it's a valid number
                                        if (selected.service && !isNaN(Number(selected.service))) {
                                            payload.service = Number(selected.service);
                                        }
                                        const created = await TemplateApi.addTemplate(payload);

                                        toast.success("Jinja2 template saved successfully");

                                        // Refresh templates list
                                        await qc.invalidateQueries({ queryKey: ["templates", template?.contractid ?? "", template?.service ?? ""] });

                                        // Poll for new template until available (max 10 attempts, 500ms interval)
                                        if (created && created.id) {
                                            const maxAttempts = 10;
                                            const pollInterval = 500;
                                            let attempts = 0;
                                            let newTpl = null;
                                            while (attempts < maxAttempts) {
                                                newTpl = await TemplateApi.getTemplateByName(
                                                    created.name,
                                                    selected.contractid ?? undefined,
                                                    selected.service ?? undefined
                                                );
                                                if (newTpl) break;
                                                await new Promise(res => setTimeout(res, pollInterval));
                                                attempts++;
                                            }
                                            if (newTpl) {
                                                setSelected(newTpl as any);
                                                setEditorValue((newTpl as any).body ?? "");
                                                setSelectedContentType(Number((newTpl as any).deviceModel ?? 0) || null);
                                                setSelectedTemplateType(Number((newTpl as any).templateType ?? 0) || null);
                                                setSelectedVendorType(Number((newTpl as any).vendorType ?? 0) || null);
                                            } else {
                                                toast.info("New template not found after saving. Please refresh or check later.");
                                            }
                                        }

                                        setJinjaModalOpen(false);
                                    } catch (err: any) {
                                        toast.error(`Save failed: ${err?.message ?? err}`);
                                    } finally {
                                        setLoading(false);
                                    }
                                }}
                            >
                                <i className="pi pi-save" style={{ marginRight: 4 }}>  </i>
                                Save
                            </Button>
                            <Button
                                style={{
                                    backgroundColor: "white",
                                    borderColor: "#d9d9d9",
                                    color: "#333",
                                    minWidth: "80px"
                                }}
                                onClick={() => setJinjaModalOpen(false)}>
                                <i className="pi pi-times" style={{ marginRight: 4 }}></i>
                                Close
                            </Button>
                        </div>
                    </div>
                </div>
            </Modal>
            {/* Save Confirmation Modal */}
            <Modal
                open={saveConfirmOpen}
                onCancel={() => setSaveConfirmOpen(false)}
                footer={null}
                centered
                closable={false}
                maskClosable={true}
                maskStyle={{ backdropFilter: "blur(2px)" }} // blur background
                width={400}
                bodyStyle={{
                    textAlign: "center",
                    padding: "24px 16px",
                    borderRadius: "12px",
                }}
            >
                <div style={{ marginBottom: 12 }}>
                    <ExclamationCircleOutlined
                        style={{
                            color: "#faad14",
                            fontSize: 36,
                            marginBottom: 8,
                        }}
                    />
                    <div
                        style={{
                            fontSize: 18,
                            fontWeight: 600,
                            color: "#333",
                        }}
                    >
                        Save Confirmation
                    </div>
                </div>

                <div style={{ marginBottom: 24, color: "#555", fontSize: 15 }}>
                    Do you want to save changes to this template?
                </div>

                <div style={{ display: "flex", justifyContent: "center", gap: "16px" }}>
                    {/* Yes */}
                    <Button
                        type="primary"
                        loading={loading}
                        style={{
                            backgroundColor: "#1677ff",
                            borderColor: "#1677ff",
                            minWidth: 80,
                        }}
                        onClick={async () => {
                            setLoading(true);
                            try {
                                await handleSave();
                                setSaveConfirmOpen(false);
                            } catch (err) {
                                toast.error("Save failed");
                            } finally {
                                setLoading(false);
                            }
                        }}
                    >
                        Yes
                    </Button>

                    {/* No */}
                    <Button
                        style={{
                            backgroundColor: "white",
                            borderColor: "#d9d9d9",
                            color: "#333",
                            minWidth: 80,
                        }}
                        onClick={() => setSaveConfirmOpen(false)}
                    >
                        No
                    </Button>
                </div>
            </Modal>

            {/* Delete Confirmation Modal (Angular Style) */}
            <Modal
                open={deleteConfirmOpen}
                onCancel={() => setDeleteConfirmOpen(false)}
                footer={null}
                centered
                width={420}
                closable={false}
                maskClosable={true}
                maskStyle={{ backgroundColor: "rgba(0,0,0,0.45)" }}
                bodyStyle={{
                    padding: 0,
                    borderRadius: 6,
                    overflow: "hidden",
                }}
            >
                {/* Header */}
                <div
                    style={{
                        backgroundColor: "#e6f1fb",
                        borderBottom: "1px solid #d9d9d9",
                        padding: "10px 16px",
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                    }}
                >
                    <span style={{ fontWeight: 600, color: "#000", fontSize: 15 }}>
                        Delete confirmation
                    </span>
                    <span
                        onClick={() => setDeleteConfirmOpen(false)}
                        style={{
                            fontSize: 16,
                            fontWeight: 600,
                            color: "#555",
                            cursor: "pointer",
                        }}
                    >
                        ×
                    </span>
                </div>

                {/* Content */}
                <div
                    style={{
                        display: "flex",
                        alignItems: "flex-start",
                        gap: 10,
                        padding: "24px 20px 12px 20px",
                        fontSize: 14.5,
                        color: "#333",
                    }}
                >
                    <ExclamationCircleOutlined
                        style={{ color: "#faad14", fontSize: 22, marginTop: 2 }}
                    />
                    <div>
                        Are you sure that you want to delete this template?
                    </div>
                </div>

                {/* Buttons */}
                <div
                    style={{
                        display: "flex",
                        justifyContent: "flex-end",
                        gap: "8px",
                        padding: "0 16px 16px 16px",
                        borderTop: "1px solid #f0f0f0",
                        marginTop: 8,
                    }}
                >
                    <Button
                        type="primary"
                        loading={loading}
                        style={{
                            backgroundColor: "#0078d4",
                            borderColor: "#0078d4",
                            minWidth: 75,
                        }}
                        onClick={async () => {
                            if (!selected) {
                                toast.error("No template selected");
                                return;
                            }
                            setLoading(true);
                            try {
                                console.log("Deleting template:", selected?.id, selected?.name);
                                await TemplateApi.deleteTemplate({ id: selected.id });
                                toast.success("Template deleted successfully");
                                setSelected(null);
                                setEditorValue("");
                                await qc.invalidateQueries({ queryKey: ["templates", template?.contractid ?? "", template?.service ?? ""] });
                                setDeleteConfirmOpen(false);
                            } catch (err: any) {
                                console.error("Delete failed:", err);
                                toast.error("Delete failed");
                            } finally {
                                setLoading(false);
                            }
                        }}
                    >
                        Yes
                    </Button>

                    <Button
                        style={{
                            borderColor: "#0078d4",
                            color: "#0078d4",
                            minWidth: 75,
                        }}
                        onClick={() => setDeleteConfirmOpen(false)}
                    >
                        No
                    </Button>
                </div>
            </Modal>

        </div>
    );
};

export default Editor;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\configurationTemplate\list_templates\addTemplateModal\addTemplateModal.tsx
"use client";

import React from "react";
import { Dialog } from "primereact/dialog";
import { InputText } from "primereact/inputtext";
import { Button } from "primereact/button";
import { Dropdown } from "primereact/dropdown";
import { InputTextarea } from "primereact/inputtextarea";
import styles from "./addTemplateModal.module.css";

interface AddTemplateDialogProps {
    visible: boolean;
    onHide: () => void;
    form: {
        name: string;
        contractid: string;
        service: string;
        templateType: string;
        deviceModel: string;
        vendorType: string;
        body: string;
    };
    errors: any;
    touched: any;
    customers: any[];
    services: any[];
    templateTypes: any[];
    contentTypes: any[];
    vendorTypes: any[];
    disableCustomer?: boolean;
    displayErrorMsg?: boolean;
    loading?: boolean;
    onChange: (field: string, value: any) => void;
    onFileUpload: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onAdd: () => void;
    onBlur?: (field: string) => void;
}

const AddTemplateDialog: React.FC<AddTemplateDialogProps> = ({
    visible,
    onHide,
    form,
    errors,
    touched,
    customers,
    services,
    templateTypes,
    contentTypes,
    vendorTypes,
    disableCustomer,
    displayErrorMsg,
    loading,
    onChange,
    onFileUpload,
    onAdd,
    onBlur
}) => (
    <Dialog header="Add new template" visible={visible} onHide={onHide} style={{ width: '60vw' }}>
        {loading && (
            <div className="application_loading">
                <i className="pi pi-spin pi-spinner" style={{ fontSize: '2em' }}></i>
                <span style={{ marginLeft: '1rem' }}>Loading data</span>
            </div>
        )}

        <div className="modal-body">
            <div className="p-field p-grid mb-2">
                <label htmlFor="name" className="p-col-fixed" style={{ width: 120 }}>Name <span id="marker_required">*</span></label>
                <div className="p-col">
                    <InputText
                        className="w-full"
                        id="name"
                        value={form.name}
                        onChange={e => onChange("name", e.target.value)}
                        onBlur={e => onBlur && onBlur("name")}
                        required
                    />
                    {/* Required field message */}
                    {!errors.pattern && !form.name && touched.name && !errors.minlength && (
                        <small className="p-error">This field is required</small>
                    )}

                    {/* No whitespaces allowed */}
                    {errors.pattern && (
                        <small className="p-error">Please type name without whitespaces!</small>
                    )}

                    {/* Minimum length */}
                    {errors.minlength && (
                        <small className="p-error">Must be longer than 5 characters!</small>
                    )}

                    {touched.name && errors.name && (
                        <small className="p-error">{errors.name}</small>
                    )}
                </div>
            </div>
            {form.name.length >= 5 && !errors.name && (
                <>
                    <div className="p-field p-grid mb-2">
                        <label htmlFor="contractid" className="p-col-fixed">Customer</label>
                        <div className="p-col">
                            <Dropdown
                                className="w-full"
                                id="contractid"
                                value={form.contractid}
                                options={customers}
                                optionLabel="name"
                                placeholder="Customers"
                                disabled={disableCustomer}
                                onChange={e => onChange("contractid", e.value)}
                                showClear
                                filter />
                            {displayErrorMsg && <small className="p-error">Please provide customer or service!</small>}
                        </div>
                    </div>
                    <div className="p-field p-grid mb-2">
                        <label htmlFor="service" className="p-col-fixed">Service</label>
                        <div className="p-col">
                            <Dropdown
                                className="w-full"
                                id="service"
                                value={form.service}
                                options={services}
                                optionLabel="serviceName"
                                placeholder="Services"
                                onChange={e => onChange("service", e.value)}
                                showClear
                                filter />
                            {displayErrorMsg && <small className="p-error">Please provide customer or service!</small>}
                        </div>
                    </div>
                    <div className="p-field p-grid mb-2">
                        <label htmlFor="templateType" className="p-col-fixed">Template type <span id="marker_required">*</span></label>
                        <div className="p-col">
                            <Dropdown
                                className="w-full"
                                id="templateType"
                                value={form.templateType}
                                options={templateTypes}
                                optionLabel="templateType"
                                placeholder="Template types"
                                onChange={e => onChange("templateType", e.value)}
                                required
                                showClear
                                filter />
                            {touched.templateType && errors.templateType && (
                                <small className="p-error">{errors.templateType}</small>
                            )}
                        </div>
                    </div>
                    <div className="p-field p-grid mb-2">
                        <label htmlFor="deviceModel" className="p-col-fixed">Content type <span id="marker_required">*</span></label>
                        <div className="p-col">
                            <Dropdown
                                className="w-full"
                                id="deviceModel"
                                value={form.deviceModel}
                                options={contentTypes}
                                optionLabel="contentType"
                                placeholder="Content types"
                                onChange={e => onChange("deviceModel", e.value)}
                                required
                                showClear
                                filter />
                            {touched.deviceModel && errors.deviceModel && (
                                <small className="p-error">{errors.deviceModel}</small>
                            )}
                        </div>
                    </div>
                    <div className="p-field p-grid mb-2">
                        <label htmlFor="vendorType" className="p-col-fixed">Vendor type <span id="marker_required">*</span></label>
                        <div className="p-col">
                            <Dropdown
                                className="w-full"
                                id="vendorType"
                                value={form.vendorType}
                                options={vendorTypes}
                                optionLabel="vendorType"
                                placeholder="Vendor types"
                                onChange={e => onChange("vendorType", e.value)}
                                required
                                showClear
                                filter />
                            {touched.vendorType && errors.vendorType && (
                                <small className="p-error">{errors.vendorType}</small>
                            )}
                        </div>
                    </div>
                    <div className="p-field p-formgrid p-grid mb-2">
                        <label htmlFor="body">Body <span id="marker_required">*</span></label>
                        <div className="p-col">
                            <InputTextarea
                                id="body"
                                value={form.body}
                                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => onChange("body", e.target.value)}
                                rows={10}
                                style={{ fontFamily: "monospace" }}
                                className={touched.body && errors.body ? "p-invalid w-full" : "w-full"} />
                            {touched.body && errors.body && (
                                <small className="p-error">{errors.body}</small>
                            )}
                        </div>
                    </div>
                </>
            )}
            <div className={`${styles.modalFooter} modal-footer flex justify-content-end gap-2`}>
                <input id="file-upload" type="file" accept=".txt" onChange={onFileUpload} />
                <Button label="Create" className="p-button" disabled={Object.values(errors).some(Boolean)} onClick={onAdd} size="small" />
                <Button label="Close" className="p-button p-button-secondary" onClick={onHide} size="small" />
            </div>
        </div>
    </Dialog>
);

export default AddTemplateDialog;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\configurationTemplate\list_templates\list_templates.tsx
"use client";
import { useActionSelectionStore } from "@/app/actions/store/actionSelectionStore";
import React, { useState, useEffect, useCallback, useRef } from "react";
// import { useSelectionStore } from "../../actions/store/selectionStore";
import { Tree } from "primereact/tree";
import { Button } from "primereact/button";
import { useSearchParams, useRouter } from "next/navigation";
// import { Template, ICarcheTemplate } from "../models/template";
import NodeListService from "../../../services/nodeListService";
import ControllerService from "../../../services/controllerService";
import AddTemplateDialog from "./addTemplateModal/addTemplateModal";
import { Toast } from "primereact/toast";

export interface Template {
    contractid: string | null;
    service: string | null;
    name: string;
    id: string | number;
    // Add other properties as needed
}

export interface ICarcheTemplate {
    contractid: string | null;
    service: string | null;
    name: string;
    id: string | number;
}

interface ListTemplatesProps {
    refresh?: string;
    contractid?: string;
    deletedTemplate?: any;
    copiedTemplate?: any;
    onEventEmitter?: (template: ICarcheTemplate) => void;
    onEventSpinner?: (state: boolean) => void;
}

interface ValidateFunction {
    (field: string, value: any): void;
}

// Define TreeNode type locally since it's not exported by primereact
export interface TreeNode {
    key?: string | number;
    label?: string;
    data?: any;
    icon?: string;
    expandedIcon?: string;
    collapsedIcon?: string;
    children?: TreeNode[];
    leaf?: boolean;
    expanded?: boolean;
    [key: string]: any;
}

const ListTemplatesComponent: React.FC<ListTemplatesProps> = ({

    refresh = "",
    contractid = "",
    deletedTemplate,
    copiedTemplate,
    onEventEmitter,
    onEventSpinner
}) => {

    const router = useRouter();
    const searchParams = useSearchParams();
    const [treeLoading, setTreeLoading] = useState(false);
    const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);
    const [listOfTemplates, setListOfTemplates] = useState<Template[]>([]);
    const [indexOfSelectedTemp, setIndexOfSelectedTemp] = useState<string | undefined>();
    const [customerId, setCustomerId] = useState<string>("");
    const [selectedTemplateName, setSelectedTemplateName] = useState("");
    const [templateTreeNodes, setTemplateTreeNodes] = useState<TreeNode[]>([]);
    const [originalTemplateTreeNodes, setOriginalTemplateTreeNodes] = useState<TreeNode[]>([]);
    const [selectedTemplateTreeNode, setSelectedTemplateTreeNode] = useState<any>(null); // selectionKeys expects an object or null
    const [showAddModal, setShowAddModal] = useState(false);
    const toast = useRef<Toast>(null);

    const setSelectionStore = useActionSelectionStore((s) => s.setSelectedNode);

    const [newTemplateName, setNewTemplateName] = useState("");
    const [form, setForm] = useState({
        name: "",
        contractid: "",
        service: "",
        templateType: "",
        deviceModel: "",
        vendorType: "",
        body: ""
    });
    interface FormErrors {
        name?: string;
        // Add other fields as needed
    }
    const [errors, setErrors] = useState<FormErrors>({});
    const [touched, setTouched] = useState({});

    const others = "others";

    // -----------------------------

    const validate: ValidateFunction = (field, value) => {
        const newErrors: FormErrors = { ...errors };
        if (field === "name" && !value) {
            newErrors.name = "Name is required";
        } else {
            delete newErrors.name;
        }
        setErrors(newErrors);
    };

    const handleChange = (field: string, value: any) => {
        setForm(prev => ({ ...prev, [field]: value }));
        validate(field, value);
    };

    const handleBlur = (field:string) => {
        setTouched(prev => ({ ...prev, [field]: true }));
    }

    // Tree traversal

    const treeTraverse = useCallback((node: TreeNode, oldKey: any, newKey: any) => {

        if (node.children) {

            node.children.forEach((childNode: any) => {

                if (childNode.key && childNode.leaf) {

                    if (childNode.key === oldKey) {
                        childNode.key = newKey;
                    }
                }
                treeTraverse(childNode, oldKey, newKey);
            });
        }
    }, []);

    // -----------------------------

    // Base nodes loading

    const getBaseNodes = useCallback(() => {

        setTreeLoading(true);
        onEventSpinner?.(true);

        NodeListService.getBasicNodes().then((result: TreeNode[]) => {
            setTreeLoading(false);
            onEventSpinner?.(false);
            setOriginalTemplateTreeNodes(result);
            setTemplateTreeNodes(result);
            //getSelectedCustomerIdFromQueryAndListOfTemplates();
            const templateId = searchParams.get("templateId");
            if (templateId) findTreeNodeBy(templateId, result);
        }).catch((err: unknown) => {
            onEventSpinner?.(false);
            toast.current?.show({
                severity: "error",
                summary: "Error",
                detail: "Error loading templates!",
                life: 3000
            });
        });
    }, [searchParams, onEventSpinner]);

    useEffect(() => {
        getBaseNodes();
    }, []);
    
    // Get customer id from query

    const getSelectedCustomerIdFromQueryAndListOfTemplates = useCallback(() => {

        const encodedCustomerId = searchParams.get("customerId");
        if (encodedCustomerId) {
            const decoded = atob(encodedCustomerId);
            setCustomerId(decoded);
            generateTreeBasedOnCustomer(decoded);
        } else {
            setTemplateTreeNodes(originalTemplateTreeNodes);
        }

    }, [searchParams, originalTemplateTreeNodes]);

    // -----------------------------

    // Refresh / Delete / Copy logic

    useEffect(() => {

        if (refresh !== "") {
            setSelectedTemplate({
                contractid: null,
                service: null,
                name: "",
                id: "",
            });
            setIndexOfSelectedTemp(undefined);
            getSelectedCustomerIdFromQueryAndListOfTemplates();
        }

        if (deletedTemplate) {

            setSelectedTemplateName("");
            let service = deletedTemplate.service || "";
            if (deletedTemplate.contractid && !deletedTemplate.service) service = others;
            if (!deletedTemplate.templateOldId) {

                removeTemplateFromNodeTreeModel(deletedTemplate.contractid, service, deletedTemplate.id);

            } else {
                templateTreeNodes.forEach((node) =>
                    treeTraverse(node, deletedTemplate.templateOldId, deletedTemplate.id)
                );
            }

        }

        if (copiedTemplate) {
            updateTree(copiedTemplate);
        }

    }, [refresh, deletedTemplate, copiedTemplate, templateTreeNodes]);

    // -----------------------------

    // Node select
    const nodeSelect = (node: TreeNode) => {
        setSelectedTemplateTreeNode(node);
        if (node.leaf) {
            const carcheTemp: ICarcheTemplate = {
                contractid: (node as any).customer || null,
                service: (node as any).service || null,
                name: node.data as string,
                id: node.key ?? ""
            };

            setSelectedTemplateName(node.data as string);
            onEventEmitter?.(carcheTemp);

            // Always update the global selection store with correct info
            setSelectionStore({
                type: carcheTemp.service ? "service" : "customer",
                id: carcheTemp.id,
                templateId: Number(carcheTemp.id),
                serviceId: carcheTemp.service ? Number(carcheTemp.id) : undefined,
                customerId: carcheTemp.contractid ? Number(carcheTemp.contractid) : undefined
            });

            router.replace(`?templateId=${carcheTemp.id}`);
            onEventSpinner?.(false);
        }
    };

    // -----------------------------

    // Generate tree based on customer

    const generateTreeBasedOnCustomer = (customerId: string) => {
        const customerIdNumber = Number(customerId);
        const customerNode: TreeNode[] = [generateMainNode("Customers")];
        originalTemplateTreeNodes[0]?.children?.forEach((customer: any) => {
            if (customer.id === customerIdNumber) customerNode[0].children!.push(customer);
        });
        getGeneralServiceNodesByCustomerService(originalTemplateTreeNodes[1]?.children || [], customerId, customerNode);
    };

    const getGeneralServiceNodesByCustomerService = (treeNode: TreeNode[], customerId: string, customerNode: TreeNode[]) => {

        setTemplateTreeNodes([]);
        const servicesNode: TreeNode[] = [generateMainNode("Services")];
        const servicesForCustomer: TreeNode[] = [];
        onEventSpinner?.(true);

        ControllerService.getServiceToCustomerById(customerId).then((custServices: any) => {
            onEventSpinner?.(false);
            custServices.services?.forEach((custService: any) => {
                treeNode.forEach((service: any) => {
                    if (service.key === custService.serviceName && service.id === custService.id) {
                        servicesForCustomer.push(service);
                    }
                });
            });

            if (servicesForCustomer.length > 0) servicesNode[0].children = servicesForCustomer;
            setTemplateTreeNodes([...customerNode, ...servicesNode]);
        });

    };

    // -----------------------------

    // Add template modal

    const handleAddTemplate = () => {
        if (!newTemplateName) return;
        const template = {
            name: newTemplateName,
            id: crypto.randomUUID(),
            contractid: null,
            service: null,
        };
        updateTree(template);
        setShowAddModal(false);
        setNewTemplateName("");

    };

    // -----------------------------

    // Update tree

    const updateTree = (template: any) => {
        const leaf = generateLeaf(template);
        if (!templateTreeNodes) getBaseNodes();
        else addTemplateToNodeTreeModel(template.contractid, template.service, leaf);
        toast.current?.show({
            severity: "success",
            summary: "Success",
            detail: "Template added succesfully!",
            life: 3000
        })
    };

    const addTemplateToNodeTreeModel = (selectedCustomer: any, selectedService: any, template: any) => {
        if (!templateTreeNodes) getBaseNodes();
        else addTemplateTreeNodeForNoneEmptyTree(selectedCustomer, selectedService, template);
    };

    const addTemplateTreeNodeForNoneEmptyTree = (selectedCustomer: any, selectedService: any, template: any) => {
        if (selectedCustomer) {
            if (!templateTreeNodes[0].expanded) templateTreeNodes[0].expanded = true;
            const customerNode = templateTreeNodes[0].children?.find(
                (node: any) => node.key === selectedCustomer.name && node.id === selectedCustomer.id
            );
            if (!customerNode) {
                templateTreeNodes[0].children!.push(generateCustomerNode(selectedCustomer));
            }
            templateTreeNodes[0].children?.forEach((customer: any) => {
                if (customer.key === selectedCustomer.name && customer.id === selectedCustomer.id) {
                    customer.expanded = true;
                    addTemplateNodeTreeService(customer.children, selectedService, template, selectedCustomer.id);
                }
            });
        } else if (selectedService && !selectedCustomer) {
            if (!templateTreeNodes[1].expanded) templateTreeNodes[1].expanded = true;
            addTemplateNodeTreeService(templateTreeNodes[1].children, selectedService, template, "");
        }
    };

    const addTemplateNodeTreeService = (treeNode: any, selectedService: any, template: any, customerId: any) => {
        treeNode.push(template);
    };

    const removeTemplateFromNodeTreeModel = (customerId: any, serviceId: any, id: any) => {
        if (!templateTreeNodes) return;
        if (customerId) {
            if (templateTreeNodes[0].children) {
                templateTreeNodes[0].children.forEach((customer: any, index: number) => {
                    if (customer.id === customerId) {
                        removeTemplateNodeTreeService(customer.children, serviceId, id);
                        if (customer.children && customer.children.length === 0) templateTreeNodes[0].children?.splice(index, 1);
                    }
                });
            }
        } else if (serviceId && !customerId) {
            if (templateTreeNodes[1].children) {
                removeTemplateNodeTreeService(templateTreeNodes[1].children, serviceId, id);
            }
        }
    };

    const removeTemplateNodeTreeService = (treeNode: any[], serviceId: any, id: any) => {
        treeNode.forEach((service: any, index: number) => {
            if (service.id === serviceId) {
                const idx = service.children.findIndex((c: any) => c.key === id);
                if (idx >= 0) service.children.splice(idx, 1);
                if (service.children.length === 0) treeNode.splice(index, 1);
            }
        });
    };

    const findTreeNodeBy = (templateId: any, nodes: TreeNode[]) => {
        nodes.forEach((node) => {
            const { key, children } = node;
            if (key === Number(templateId)) {
                setSelectedTemplateTreeNode(node);
                nodeSelect(node);
            } else if (children) {
                findTreeNodeBy(templateId, children);
            }
        });
    };

    // -----------------------------

    // Node generation helpers

    const generateLeaf = (child: any): TreeNode => ({
        label: child.name,
        key: child.id,
        icon: "pi pi-file",
        data: child.name,
        service: child.service,
        leaf: true,
        customer: child.contractid,
    });

    const generateMainNode = (name: string): TreeNode => ({
        label: name,
        key: name,
        level: 1,
        data: name + " Folder",
        expandedIcon: "pi pi-folder-open",
        collapsedIcon: "pi pi-folder",
        children: [],
    });

    const generateCustomerNode = (customer: any): TreeNode => ({
        label: customer.name,
        key: customer.name,
        data: customer.name,
        id: customer.id,
        children: [],
    });

    return (
        <div>
            <Toast ref={toast} />
            <div style={{ marginTop: 12, borderBottom: "1px solid #c8c8c8" }}>
                <p style={{ textAlign: "center", minHeight: 24 }}>{selectedTemplateName}</p>
            </div>

            {templateTreeNodes.length > 0 && (
                <div className="mb-2">
                    <div style={{ maxHeight: "800px", overflow: "auto" }}>
                        <Tree
                            value={templateTreeNodes}
                            selectionMode="single"
                            selectionKeys={selectedTemplateTreeNode}
                            onSelectionChange={(e) => {
                                setSelectedTemplateTreeNode(e.value);
                                // Find the selected node object and pass to nodeSelect
                                const findNodeByKey = (nodes: TreeNode[], key: any): TreeNode | null => {
                                    for (const node of nodes) {
                                        if (node.key === key) return node;
                                        if (node.children) {
                                            const found = findNodeByKey(node.children, key);
                                            if (found) return found;
                                        }
                                    }
                                    return null;
                                };
                                const selectedKey = e.value;
                                const selectedNode = findNodeByKey(templateTreeNodes, selectedKey);
                                if (selectedNode) nodeSelect(selectedNode);
                            }}
                            loading={treeLoading}
                            filter
                            filterMode="lenient"
                        />
                    </div>
                </div>

            )}

            <div style={{ textAlign: "center" }}>
                <Button icon="pi pi-plus" className="p-button" label="Add new template" onClick={() => setShowAddModal(true)} size="small" />
            </div>

            <AddTemplateDialog
                visible={showAddModal}
                onHide={() => setShowAddModal(false)}
                form={form}
                errors={errors} // Provide an empty object or appropriate value
                touched={touched} // Provide an empty object or appropriate value
                customers={[]} // Provide an empty array or appropriate value
                services={[]} // Provide an empty array or appropriate value
                templateTypes={[]} // Provide an empty array or appropriate value
                contentTypes={[]} // Provide an empty array or appropriate value
                vendorTypes={[]} // Provide an empty array or appropriate value
                disableCustomer={false} // Provide a boolean or appropriate value
                displayErrorMsg={false} // Provide a boolean or appropriate value
                loading={false} // Provide a boolean or appropriate value
                onChange={handleChange} // Provide a no-op or appropriate handler
                onFileUpload={() => { }} // Provide a no-op or appropriate handler
                onAdd={handleAddTemplate}
                onBlur={handleBlur}
            />
        </div>

    );

};

export default ListTemplatesComponent;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\configurationTemplate\configurationTemplate.tsx
// src/components/configTemplates/ConfigTemplatesPage.tsx
"use client";

import React, { useEffect, useState } from "react";
import { useSearchParams } from "next/navigation";
import { ProgressSpinner } from "primereact/progressspinner";
import ListTemplates from "./list_templates/list_templates";
import { Template, ICarcheTemplate } from "../configurationTemplate/list_templates/list_templates";
import Editor from "./editor/editor";
import { useDebounce } from "use-debounce";

const TemplateManager: React.FC = () => {

    const [contractId, setContractId] = useState<string>("");
    const [refresh, setRefresh] = useState<string>("");
    const [template, setTemplate] = useState<Template | undefined>(undefined);
    const [deletedTemplate, setDeletedTemplate] = useState<any>(null);
    const [copiedTemplate, setCopiedTemplate] = useState<any>(null);
    const [showSpinner, setShowSpinner] = useState<boolean>(false);
    const searchParams = useSearchParams();

    // 👇 React equivalent of ngOnInit()

    useEffect(() => {
        // setShowSpinner(true);
        getSelectedCustomerFromQuery();
    }, []);

    /**
  
     * Parse query params (replacement for Angular ActivatedRoute)
  
     */

    const getSelectedCustomerFromQuery = () => {

        //const searchParams = new URLSearchParams(location.search);
        const customerName = searchParams.get("customerName");
        const customerId = searchParams.get("customerId");

        if (customerName && customerId) {

            try {
                const decodedId = atob(customerId);
                setShowSpinner(true);

            } catch (e) {
                console.error("Invalid customerId:", e);
            }

        }

    };

    /**
  
     * Called when user selects or edits a template
  
     */

    const sendTemplate = (tmpl: Template) => {
        setShowSpinner(true);
        setTemplate(tmpl);
        // stop spinner after data parses to the right panel
        setTimeout(() => {
            setShowSpinner(false);
        },);
    };

    /**
  
     * Toggle spinner state
  
     */

    const spinnerStatus = (status: boolean) => {
        console.log("Spinner status:", status);
        setShowSpinner(status);
    };

    /**
  
     * Handle delete event from editor
  
     */

    const deleteTemplateEvent = (deleted: any) => {
        setTemplate(undefined);
        setDeletedTemplate(deleted);

    };

    /**
  
     * Handle copy event from editor
  
     */

    const copyTemplateEvent = (copied: any) => {
        setCopiedTemplate(copied);
    };

    return (
        <>
            <section className="pb-3 pl-3 pr-3 pt-3">
                {showSpinner && (
                    <div className="application_loading">
                        <ProgressSpinner animationDuration=".8s" />
                    </div>
                )}
                <div className="flex h-screen w-full overflow-hidden">
                    {/* left panel */}
                    <div className="w-1/4 h-full flex-shrink-0">
                        <div className="border-gray-300" id="left_side_panel">
                            <ListTemplates
                                refresh={refresh}
                                copiedTemplate={copiedTemplate}
                                deletedTemplate={deletedTemplate}
                                contractid={contractId}
                                onEventSpinner={spinnerStatus}
                                onEventEmitter={sendTemplate}
                            />
                        </div>
                    </div>

                    {/* right panel */}
                    <div className="w-3/4 h-full overflow-y-auto overflow-x-hidden">
                        <div className="min-w-max border-gray-300" id="right_side_panel"> {/* <div className="border-gray-300" id="right_side_panel" style={{ overflow: "hidden" }}> */}
                            <Editor template={template} onEventSpinner={spinnerStatus} />
                        </div>
                    </div>

                </div>
            </section>
        </>
    );
};

export default TemplateManager;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\configurationTemplate\page.tsx
// i have ceated this file to export configurationTemplate component directly
// src/app/configuration-templates/page.tsx
"use client";
import ConfigurationTemplate from "../configurationTemplate/configurationTemplate";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

export default function ConfigurationTemplatesPage() {
  return (
    <QueryClientProvider client={queryClient}>
      <ConfigurationTemplate />
    </QueryClientProvider>
  );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\services\controllerService.ts

// src/app/services/controllerService.ts
import axios from "axios";
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API, // e.g. https://selfservice.dev.att.com/api
  withCredentials: true,
});
 
//  Helper to unwrap Angular-like result
const unwrap = (res: any, key: string = "result") => {
  if (res?.data?.[key]) return res.data[key];
  if (Array.isArray(res?.data)) return res.data; // raw array
  if (res?.data) return res.data;
  return [];
};
 
// ----------------- Customers -----------------
export async function getCustomers() {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/customers/status/?active=true`);
  if (!res.ok) throw new Error("Failed to fetch customers");
  const json = await res.json();
  return json.result;
}
 
// / ----------------- Services -----------------
export async function getServices() {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/service/`);
  if (!res.ok) throw new Error("Failed to fetch services");
  const json = await res.json();
  return json.result ?? json;
}
 
export async function getServicesByCustomerId(customerId: string) {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/customer/service/?customerId=${customerId}`);
  if (!res.ok) throw new Error("Failed to fetch services by customer");
  const json = await res.json();
  return json.result ?? json;
}
 
// ----------------- Vendors -----------------
export async function getVendors() {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  const res = await fetch(`${baseUrl}/cArche/template/vendor-types/`);
  if (!res.ok) throw new Error("Failed to fetch vendors");
  const json = await res.json();
  return json.result ?? json;
}
 
// ----------------- Action Types -----------------
export async function getActionTypes() {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  try {
    const res = await fetch(`${baseUrl}/workflows/`);
    if (!res.ok) {
      console.error("getActionTypes: non-OK response", res.status);
      return [];
    }
    const json = await res.json();
    const payload = json.result ?? json;
 
    if (
      payload &&
      typeof payload === "object" &&
      !Array.isArray(payload) &&
      (payload.redirectUrl || payload.path || payload.src === "OIDC")
    ) {
      if (typeof window !== "undefined" && payload.redirectUrl) {
        window.location.href = payload.redirectUrl;
      }
      return [];
    }
 
    const raw = Array.isArray(payload) ? payload : Array.isArray(json) ? json : [];
    if (!Array.isArray(raw)) return [];
 
    if (typeof window !== "undefined") {
      console.debug("getActionTypes raw full:", raw);
      console.debug("getActionTypes raw sample:", raw[0]);
    }
 
    return raw.map((a: any) => {
      if (a == null) return { ID: null, NAME: "" };
      if (typeof a !== "object") return { ID: a, NAME: String(a) };
 
      const id =
        a.ID ??
        a.id ??
        a.workflowId ??
        a.value ??
        a._id ??
        (a.workflow && (a.workflow.id ?? a.workflow.workflowId)) ??
        null;
 
      const name =
        a.NAME ??
        a.name ??
        a.workflowName ??
        a.label ??
        a.displayName ??
        a.title ??
        (a.workflow && (a.workflow.name ?? a.workflow.NAME)) ??
        a.path ??
        a.src ??
        (() => {
          try {
            const str = JSON.stringify(a);
            return str.length > 120 ? str.slice(0, 120) + "..." : str;
          } catch {
            return "";
          }
        })();
 
      return {
        ...a,
        ID: id,
        NAME: name,
      };
    });
  } catch (err: any) {
    console.error("❌ getActionTypes error:", err?.message ?? err);
    return [];
  }
}
 
// ----------------- Hostnames -----------------
export async function getHostnames(customerId: string) {
  if (!customerId) return [];
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  try {
    const res = await fetch(`${baseUrl}/cache/devices/?customerId=${encodeURIComponent(customerId)}`);
    if (!res.ok) {
      console.warn("getHostnames: non-OK response", res.status);
      return [];
    }
    const json = await res.json();
    const data = json.result ?? json;
    if (!Array.isArray(data)) return [];
 
    return data.map((d: any, i: number) => {
      const hostname =
        d.HOSTNAME ??
        d.hostname ??
        d.deviceName ??
        d.name ??
        d.hostName ??
        (typeof d === "string" ? d : null);
      return {
        ID: d.id ?? d.deviceId ?? i,
        HOSTNAME: hostname,
      };
    });
  } catch (err: any) {
    console.error("❌ getHostnames error:", err?.message ?? err);
    return [];
  }
}
 
// ----------------- Rollback Timers -----------------
export async function getRollbackTimers() {
  return [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];
}
 
// ----------------- Workflow Attributes -----------------
export async function getWorkflowAttributes(workflowId: string) {
  const defaults = {
    validation: { required: false, enabled: true },
    hostname: { required: false, enabled: false },
    configurationTemplate: { required: false, enabled: true },
    apiEndpoint: { required: false, enabled: true },
  };
 
  if (!workflowId) return defaults;
 
  try {
    try {
      const res1 = await api.get(`/workflow/attribute/`, { params: { id: workflowId } });
      const attrs1 = unwrap(res1, "result");
      if (Array.isArray(attrs1) && attrs1.length > 0) {
        return {
          validation: {
            required: attrs1.find((a: any) => a.id === 1)?.status === "required",
            enabled: attrs1.find((a: any) => a.id === 1)?.status !== "disabled",
          },
          hostname: {
            required: attrs1.find((a: any) => a.id === 3)?.status === "required",
            enabled: attrs1.find((a: any) => a.id === 3)?.status !== "disabled",
          },
          configurationTemplate: {
            required: attrs1.find((a: any) => a.id === 4)?.status === "required",
            enabled: attrs1.find((a: any) => a.id === 4)?.status !== "disabled",
          },
          apiEndpoint: {
            required: attrs1.find((a: any) => a.id === 5)?.status === "required",
            enabled: attrs1.find((a: any) => a.id === 5)?.status !== "disabled",
          },
        };
      }
    } catch (e) {
      if (typeof window !== "undefined")
        console.debug("getWorkflowAttributes: /workflow/attribute/ failed", (e as any)?.message ?? e);
    }
 
    try {
      const res2 = await api.get(`/workflows/${workflowId}/attributes`);
      const attrs2 = unwrap(res2, "result");
      if (Array.isArray(attrs2) && attrs2.length > 0) {
        return {
          validation: {
            required: attrs2.find((a: any) => a.id === 1)?.status === "required",
            enabled: attrs2.find((a: any) => a.id === 1)?.status !== "disabled",
          },
          hostname: {
            required: attrs2.find((a: any) => a.id === 3)?.status === "required",
            enabled: attrs2.find((a: any) => a.id === 3)?.status !== "disabled",
          },
          configurationTemplate: {
            required: attrs2.find((a: any) => a.id === 4)?.status === "required",
            enabled: attrs2.find((a: any) => a.id === 4)?.status !== "disabled",
          },
          apiEndpoint: {
            required: attrs2.find((a: any) => a.id === 5)?.status === "required",
            enabled: attrs2.find((a: any) => a.id === 5)?.status !== "disabled",
          },
        };
      }
    } catch (e) {
      if (typeof window !== "undefined")
        console.debug("getWorkflowAttributes: /workflows/{id}/attributes failed", (e as any)?.message ?? e);
    }
 
    return defaults;
  } catch (err: any) {
    if (typeof window !== "undefined") console.debug("getWorkflowAttributes unexpected error:", err?.message ?? err);
    return defaults;
  }
}
 
// ----------------- Save Action (UPDATED ENDPOINT) -----------------
export async function saveAction(payload: any) {
  try {
    const flatPayload = { ...payload };

    if (payload.customer && typeof payload.customer === "object") {
      flatPayload.customerId = payload.customer.id ?? payload.customer.ID ?? payload.customer;
    }
    if (payload.service && typeof payload.service === "object") {
      flatPayload.serviceId = payload.service.id ?? payload.service.ID ?? payload.service;
    }
    if (payload.actionType && typeof payload.actionType === "object") {
      flatPayload.workflowId = payload.actionType.id ?? payload.actionType.ID ?? payload.actionType;
    } else if (payload.actionType) {
      flatPayload.workflowId = payload.actionType;
    }
    if (payload.vendor && typeof payload.vendor === "object") {
      flatPayload.vendorTypeId = payload.vendor.id ?? payload.vendor.ID ?? payload.vendor;
    }

    delete flatPayload.customer;
    delete flatPayload.service;
    delete flatPayload.actionType;
    delete flatPayload.vendor;

    // Use the same endpoint as Angular for create action
    const res = await api.post("/action-template/", flatPayload);
    return res.data;
  } catch (err: any) {
    console.error("❌ saveAction error:", err.response?.status, err.message);
    throw err;
  }
}
 
// ----------------- Load Action Type for Action Template -----------------
export async function loadActionTypeForActionTemplate(actionId: string) {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
  if (!actionId) return [];
 
  try {
    const res = await fetch(`${baseUrl}/workflow/action/?id=${encodeURIComponent(actionId)}`);
    if (!res.ok) {
      console.debug("loadActionTypeForActionTemplate non-OK:", res.status);
      return [];
    }
    const json = await res.json();
    const raw = json.result ?? json;
    if (!Array.isArray(raw)) return [];
 
    return raw.map((a: any) => {
      if (a == null) return { ID: null, NAME: "" };
      if (typeof a !== "object") return { ID: a, NAME: String(a) };
 
      const id =
        a.ID ??
        a.id ??
        a.workflowId ??
        a.value ??
        a._id ??
        (a.workflow && (a.workflow.id ?? a.workflow.workflowId)) ??
        null;
 
      const name =
        a.NAME ??
        a.name ??
        a.workflowName ??
        a.label ??
        a.displayName ??
        a.title ??
        (a.workflow && (a.workflow.name ?? a.workflow.NAME)) ??
        a.path ??
        a.src ??
        (() => {
          try {
            const str = JSON.stringify(a);
            return str.length > 120 ? str.slice(0, 120) + "..." : str;
          } catch {
            return "";
          }
        })();
 
      return { ...a, ID: id, NAME: name };
    });
  } catch (err: any) {
    console.debug("loadActionTypeForActionTemplate error:", err?.message ?? err);
    return [];
  }
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\clientTooltipProvider.tsx
"use client";
import { Tooltip } from 'primereact/tooltip';

export default function ClientTooltipProvider() {
  return <Tooltip target=".my-group-plus-btn" />;
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\layout.tsx
import type { Metadata } from "next";
// Removed Geist font imports; using ATTAleckSans_W_Rg.ttf instead
import "./globals.css";

import 'primereact/resources/themes/saga-blue/theme.css';
import 'primereact/resources/primereact.min.css';
import 'primeflex/primeflex.css';
import 'primeicons/primeicons.css';
import ClientTooltipProvider from "./clientTooltipProvider";
import Navbar from "./components/navbar";

// Font-face is defined in globals.css for ATTAleckSans_W_Rg.ttf

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">

      <body className="font-aleck antialiased">
        <Navbar />
        <ClientTooltipProvider />
        {children}
      </body>
    </html>
  );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\app\page.tsx

"use client";
import "primereact/resources/themes/lara-light-blue/theme.css";
import "primereact/resources/primereact.min.css";
import "primeicons/primeicons.css";
import ConfigurationTemplate from "../app/configurationTemplate/configurationTemplate";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const queryClient = new QueryClient();
import { useSearchParams } from "next/navigation";
import FormRulesTab from "./actions/form-rules/formRulesTab";
import Image from "next/image";
import ActionAccess from "./components/actions/action-access/action-access";

import React from "react";
import Navbar from "./components/navbar";

// export default function Home() {
//   const searchParams = useSearchParams();
//   const actionId = Number(searchParams.get("actionId"));

//   return (
//     <QueryClientProvider client={queryClient}>
//       <ConfigurationTemplate />
//       <ReactQueryDevtools initialIsOpen={false} />
//     </QueryClientProvider>
//     <FormRulesTab actionId={actionId} templateId={actionId} />


// export default function Home() {
//     return (
//       <ActionAccess />
//     );
// }   

    // import LeftPanel from "./components/left-panel";

export default function Page() {
  return (
    <>  
      <div style={{ display: "flex", height: "100vh", flexDirection: "column" }}>
        {/* <Navbar /> */}              
        
        <div style={{ display: "flex", flex: 1 }}>
          {/* Left panel with customers/services */}
          {/* <LeftPanel /> */}
          {/* Main content placeholder */}
          <div style={{ flex: 1, padding: "20px" }}>
            {/* <h1>Welcome! Select a customer and service.</h1> */}
          </div>
        </div>
      </div>
    </>
  );
}

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\lib\authHelper.ts
  /**
 * Generates a Basic Authentication header value.
 * @returns {string} The Basic Auth header value.
 */
export const generateBasicAuthHeader = (): string => {
  const username = process.env.NEXT_PUBLIC_API_USERNAME;
  const password = process.env.NEXT_PUBLIC_API_PASSWORD;

  if (!username || !password) {
    throw new Error('Missing NEXT_PUBLIC_API_USERNAME or NEXT_PUBLIC_API_PASSWORD environment variables');
  }

  return 'Basic ' + Buffer.from(`${username}:${password}`).toString('base64');
};

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\actionService.ts
import { Subject } from 'rxjs';

export interface Access {
    ID: number;
    [key: string]: any;
    inherited?: boolean;
}

export const actionService = {
    actionServices: [
        { id: 1, name: "Default Service" } // Add your actual service objects here
    ],

    actionLoadCompleteSubject: new Subject<boolean>(),

    actionTemplate: { id: 1 },

    action: {
        actionAccesses: {
            businessCenter: [] as Access[],
            group: [] as Access[],
            individual: [] as Access[],
        },
        actionCache: {} as Record<string, any>,
    },

    customer: {
        id: 1, // or null/undefined if not set by default
        // ...other customer properties if needed
    },

    _cache: {} as Record<string, any>,

    getActionCache(key: string) {
        return (key in this.action.actionCache) ? this.action.actionCache[key] : null;
        //return this._cache[key];
    },

    setActionCache(key: string, value: any) {
        this.action.actionCache[key] = value;
    }

};

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\apiConnectService.ts

import axios from "axios";
import { generateBasicAuthHeader } from "../lib/authHelper";

const BASE = process.env.NEXT_PUBLIC_API ?? "http://localhost:8000/api";
const API_BASE = BASE.endsWith("/") ? BASE.slice(0, -1) : BASE;

const api = axios.create({
  baseURL: API_BASE,
  withCredentials: true,
  headers: {
    // "Content-Type": "application/json",
    "Authorization": generateBasicAuthHeader(),
  },
});
// Types
export interface TemplateResponse {
  id: number;
  name: string;
  version?: string | number;
  contractid?: string;
  service?: string;
  deviceModel?: string | number;
  vendorType?: string | number;
  templateType?: string | number;
  body?: string;
  dateCreated?: string;
}
export interface VariableResponse {
  [key: string]: string | number | boolean | null;
}
export interface NodeListResponse {
  // minimal typing — the Angular JSON is large; we'll type loosely
  [key: string]: any;
}
export interface SimpleIdName {
  id: number;
  contentType?: string;
  templateType?: string;
  vendorType?: string;
  [key: string]: any;
}
// API
const TemplateApi = {
  // Check template usage (dummy implementation, replace endpoint as needed)
  async checkTemplateUsage(id: string | number, name: string) {
    // Replace with your actual backend endpoint if available
    // Example: /cArche/template/usage/?id=...&name=...
    try {
      const params = { id: String(id), name };
      const res = await api.get("/cArche/template/usage/", { params });
      return res.data;
    } catch (err) {
      // If endpoint not available, return empty array
      return [];
    }
  },
  async contentTypes() {
    const res = await api.get<SimpleIdName[]>("/cArche/template/content-types/");
    return res.data;
  },
  async templateTypes() {
    const res = await api.get<SimpleIdName[]>("/cArche/template/types/");
    return res.data;
  },
  async vendorTypes() {
    const res = await api.get<SimpleIdName[]>("/cArche/template/vendor-types/");
    return res.data;
  },
  // Templates list (by contract/service) — Angular called this listTemplates endpoint (we also include this /cArche route)
  async listTemplates(contractId?: string | null, serviceId?: string) {
    // Use the cArche list endpoint (matches routes.js)
    const params: Record<string, string> = {};
    if (contractId) params.contractid = contractId;
    if (serviceId) params.service = serviceId;

    const res = await api.get<TemplateResponse[]>("/cArche/template-list/contract-id/service/", { params });
    return res.data;
  },
  // Get single template (same as Angular: /cArche/template/?name=...&contractid=...&service=...)
  async getTemplateByName(name?: string, contractId?: string, serviceId?: string) {
    const params: Record<string, string> = {};
    if (name) params.name = name;
    if (contractId) params.contractid = contractId;
    if (serviceId) params.service = serviceId;
    const res = await api.get<TemplateResponse[]>("/cArche/template/", { params });
    // backend returns array — mirror Angular behaviour: return first if array
    const data = res.data;
    return Array.isArray(data) ? (data[0] ?? null) : data;
  },
  // Create / Update / Delete
  async addTemplate(payload: Partial<TemplateResponse> & { body: string }) {
    const res = await api.post("/cArche/template/", payload);
    return res.data;
  },
  async updateTemplate(payload: Partial<TemplateResponse> & { id: number }) {
    const res = await api.put("/cArche/template/", payload);
    return res.data;
  },
  async deleteTemplate(params: { id?: number; contractid?: string; service?: string; name?: string }) {
    const res = await api.delete("/cArche/template/", { params });
    return res.data;
  },
  // Variables (3 flavors)
  async getVariablesByContract(name: string, contractId: string, templateType: string) {
    const params = { name, contractid: contractId, templateType };
    const res = await api.get<VariableResponse>("/cArche/variables/name/contract-id/", { params });
    return res.data;
  },
  async getVariablesByService(name: string, service: string, templateType: string) {
    const params = { name, service, templateType };
    const res = await api.get<VariableResponse>("/cArche/variables/name/service/", { params });
    return res.data;
  },
  async getVariablesByTemplateId(id: string, templateType: string) {
    const params = { id, templateType };
    const res = await api.get<VariableResponse>("/cArche/variables/template-id/", { params });
    return res.data;
  },

  // Convert to Jinja (matches controller)
  async convertToJinja(data: string) {
    const res = await api.post("/cArche/template/convert-to-jinja/", { data });
    // console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>convertToJinja response:", res.data);
    const result = res.data;
    // Return plain string like angular
    if (typeof result === "string") return result;
    if (result?.data && typeof result.data === "string") return result.data;
    if (result?.converted && typeof result.converted === "string") return result.converted;
    return JSON.stringify(result, null, 2);
  },
};

export default TemplateApi;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\controllerService.ts
import axios from 'axios';


// const controllerService = {

// async getServiceToCustomerById(id: string) {
//   const response = await axios.get(
//     `${process.env.NEXT_PUBLIC_API}/customer/service`,
//     { params: { customerId: id } }
//   );
//   return response.data;
// }
// }

// export default controllerService;

import httpClient from "./httpClient";
// import axios from 'axios';
import { interceptedFetch } from '../../lib/interceptor' 


const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL;
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000/api';


export async function getFormTemplateById(id: number) {
  // This hits /action-template/?id= on backend, returns fields/questions for dropdowns.
  const res = await httpClient.get(`/action-template/?id=${id}`);
  // This hits /action-template/:id on your backend, returns fields/questions for dropdowns.
//   const res = await httpClient.get(`/action-template/${id}`);
  return res.data;
}

/**
 * Deletes a BC User for an Action Template.
 * @param bcUserId The ID of the BC User.
 * @param actionTemplateId The ID of the Action Template.
 * @returns Promise<any>
 */
const controllerService = {

    async getTemplateToBcUser(actionTemplateId: number): Promise<any> {
        try {
            const url = `${API_BASE_URL}/permission/template/customer/?templateId=${encodeURIComponent(actionTemplateId)}`;
            const res = await axios.get(url);
            return res.data;
        } catch (error: any) {
            throw new Error(`Failed to fetch: ${error.message}`);
        }
    },

    async getRolesForServiceAndCustomer(customerId: string, serviceId: string): Promise<any[]> {
        try {
            const params = new URLSearchParams({
                serviceId,
                customerId,
            });
            const res = await axios.get<any[]>(`${API_BASE_URL}/permission/service/role/`, {
                params,
            });
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch roles for service and customer');
        }
    },

    async getBcUserForServiceAndCustomer(customerId: number, serviceId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/customers/${customerId}/services/${serviceId}/bc-users`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch BC users for service and customer');
        }
    },

    async getBcUserForServices(serviceId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/services/${serviceId}/bc-users`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch BC users for service');
        }
    },

    async getTemplateToRole(actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/action-templates/${actionTemplateId}/roles`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch roles assigned to template');
        }
    },

    async getRolesForServices(serviceId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/services/${serviceId}/roles`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch roles for service');
        }
    },

    async getTemplateToUser(actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/action-templates/${actionTemplateId}/users`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch users assigned to template');
        }
    },

    async getUsersForServiceAndCustomer(customerId: number, serviceId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/customers/${customerId}/services/${serviceId}/users`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch users for service and customer');
        }
    },

    async getUserForServices(serviceId: number): Promise<any> {
        try {
            const res = await axios.get(`${API_BASE_URL}/services/${serviceId}/users`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch users for service');
        }
    },

    async assignTemplateToUser(userId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.post(`${API_BASE_URL}/action-templates/${actionTemplateId}/users/${userId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to assign template to user');
        }
    },

    async getExistingUsersFromDB(): Promise<any[]> {
        try {
            const res = await axios.get(`${API_URL}/users/`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch users');
        }
    },

    async getBcUsers(): Promise<any[]> {
        try {
            const res = await axios.get(`${API_URL}/bc/users/`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch business center users');
        }
    },

    async getRoles(): Promise<any[]> {
        try {
            const res = await axios.get(`${API_URL}/roles/`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to fetch roles');
        }
    },

    async deleteBcUserForActionTemplate(bcUserId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.delete(`${API_BASE_URL}/action-templates/${actionTemplateId}/bc-users/${bcUserId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to delete BC User for Action Template');
        }
    },

    async assignTemplateToRole(roleId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.post(`${API_BASE_URL}/action-templates/${actionTemplateId}/roles/${roleId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to assign template to role');
        }
    },

    async deleteRoleForActionTemplate(roleId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.delete(`${API_BASE_URL}/action-templates/${actionTemplateId}/roles/${roleId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to delete role for Action Template');
        }
    },

    async deleteUsersForActionTemplate(userId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.delete(`${API_BASE_URL}/action-templates/${actionTemplateId}/users/${userId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to delete user for Action Template');
        }
    },

   async assignTemplateToBCUser(bcUserId: number, actionTemplateId: number): Promise<any> {
        try {
            const res = await axios.post(`${API_BASE_URL}/action-templates/${actionTemplateId}/bc-users/${bcUserId}`);
            return res.data;
        } catch (error: any) {
            throw new Error('Failed to assign template to BC User');
        }
    },
};

export default controllerService;

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\formRulesService.ts
import httpClient from "./httpClient";
 
export interface WhenCondition {
  source_key: string;
  condition: string;
  value: string;
  operation?: "OR" | "AND";
}
 
export interface ThenCondition {
  target_key: string;
  action: string;
  target_value: string;
}
 
export interface FormRule {
  ID: number;
  SEQUENCE: number;
  WHEN_CONDITIONS: WhenCondition[];
  THEN_CONDITIONS: ThenCondition[];
  TEMPLATE_ID: number;
}

// please check these two function which one do you need

// GET with belongsTo and correct param name
export async function fetchFormRules(
  actionId: number,
  belongsTo: string
): Promise<FormRule[]> {
  const res = await httpClient.get(
    `/form-rules?template_id=${actionId}&belongsTo=${belongsTo}`
  );
  return res.data;
}

// POST with correct param name
 
// export async function fetchFormRules(actionId: number): Promise<FormRule[]> {
//   const res = await httpClient.get(`/form-rules?template_id=${actionId}`);
//   return res.data;
// }
 
export async function createFormRule(
  actionId: number,
  sequence: number,
  when_conditions: WhenCondition[],
  then_conditions: ThenCondition[]
) {
  return httpClient.post(`/form-rules`, {
    template_id: actionId,
    sequence,
    when_conditions,
    then_conditions,
  });
}
 
export async function editFormRule(
  id: number,
  when_conditions: WhenCondition[],
  then_conditions: ThenCondition[]
) {
  return httpClient.patch(`/form-rules/${id}`, {
    when_conditions,
    then_conditions,
  });
}
 
export async function deleteFormRule(id: number) {
  return httpClient.delete(`/form-rules/${id}`);
}
 
export async function incrementFormRuleSequence(id: number, increment: boolean) {
  return httpClient.put(`/form-rules/increment-sequence/${id}`, { increment });
}
 
C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\httpClient.ts
import axios from "axios";
 
const httpClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE, // e.g. http://localhost:3001
  headers: { "Content-Type": "application/json" },
});
 
// Optional interceptors for auth/logging
httpClient.interceptors.request.use(
  (config) => {
    // Example: attach token
    // const token = localStorage.getItem("token");
    // if (token) config.headers.Authorization = `Bearer ${token}`;
    return config;
  },
  (error) => Promise.reject(error instanceof Error ? error : new Error(error))
);
 
httpClient.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error("API Error:", error.response?.data || error.message);
    return Promise.reject(error instanceof Error ? error : new Error(error));
  }
);
 
export default httpClient;
 

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\services\nodeListService.ts
import axios from 'axios';
import { generateBasicAuthHeader } from '../lib/authHelper';

const nodeListService = {

  async getBasicNodes() {
    const username = process.env.NEXT_PUBLIC_USERNAME;
    const password = process.env.NEXT_PUBLIC_PASSWORD;
    const basicAuth = 'Basic ' + Buffer.from(username + ':' + password).toString('base64');
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_API}/node-list/`,
      {
        headers: {
          'Authorization': basicAuth
        }
      }
    )
    return response.data;
  },
}

export default nodeListService;


C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\src\types\ace.d.ts
declare module 'ace-builds/src-noconflict/ace' {
  const ace: any;
  export default ace;
}
declare module 'ace-builds/src-noconflict/ext-language_tools';
declare module 'ace-builds/src-noconflict/mode-django';
declare module 'ace-builds/src-noconflict/theme-github';

C:\Users\sa3590\Downloads\sakp\apm0013173-one-creator-nextjs\.env.local
NEXT_PUBLIC_API_USERNAME=sa3590@csp.att.com
NEXT_PUBLIC_API_PASSWORD=Bangalore@10203040
NEXT_PUBLIC_API_BASE_URL= http://localhost:8000/api      # navbar
NEXT_PUBLIC_API_BASE=http://localhost:8000/api           # this for rormrules tab
NEXT_PUBLIC_API=http://localhost:8000/api                # leftpanel nodelist - keerthana












 
